<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Object-oriented programming</title>
	<meta name="description" content="programming paradigm OOP in C#, concept of classes and objects, attributes and methods">
	<meta name="keywords" content="c#, oop, class, object, interface">
	<meta name="author" content="Edward & Albert">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Объектно-ориентированное программирование</h1>
                    <h3>Классы и объекты</h3>
                    <p>
                        <small>Edward &amp; Albert / <a href="https://github.com/tgjmjgj/sharp/">github:Tgjmjgj</a></small>
                    </p>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
            </section>
            <section>
				<h1>Объектно-ориентированное программирование</h1>
				<blockquote>
					Что важно понять при работы с ООП, - это то, что все типы являются классами.
				</blockquote>
				<p>
					Ваша программа описана в классе программы, для работы с консолью используется
					класс консоли, для работы с окнами - класс окна, для работы с лохматым померанским 
					шпицем - класс собачки.
				</p>
			</section>
			<section>
				<section>
					<h1>Классы и объекты</h1>
					<blockquote>
						<span class="purple">Класс</span> - это абстрактный тип данных, определяемый программистом.
					</blockquote>
					<blockquote>
						<span class="purple">Объекты</span> - это экземпляры класса, т.е. переменные типа класса.
					</blockquote>
					<pre>
						<code class="cs">
// Объявление класса
class ИмяКласса
{
	// члены класса
}
						</code>
					</pre>
					<blockquote>
						Члены класса - это данные и функции для работы с этими данными.
					</blockquote>
					<blockquote>
						Имя класса можно считать именем нового типа данных.
					</blockquote>
				</section>
				<section>
					<h2>Класс и его экземпляры</h2>
					<p>
						Класс можно считать "чертежом", "схемой" какого-либо объекта. Класс сам по себе 
						является просто описанием какой-либо сущности. 
					</p>
					<p>
						Объект (экземпляр) же является фактическим представлением этой сущности.
					</p>
					<p>
						Например Boeing777 - класс, представляющий одноимённый самолёт. Но это еще не какой-либо 
						конкретный самолёт этой модели. Можно создать экзампляры этого класса boeing1, boeing2
						и boeign3, которые уже будут представляться реальные воплощения, 3 разных самолёта 
						такой модели.
					</p>
				</section>
				<section>
					<h2>Создание экземпляра класса</h2>
					<blockquote>
						Создание объекта класса осуществляется с помощью оператора <span class="blue">new</span>:
					</blockquote>
					<pre>
						<code class="cs">
ИмяКласса имяОбъекта = new ИмяКласса();
						</code>
					</pre>
					<pre>
						<code class="cs">
Random rand = new Random();
DateTime dt = new DateTime(1991, 10, 23);
string[] mas = new string[4];
List&lt;int&gt; list = new List&lt;int&gt;();
						</code>
					</pre>
				</section>
				<section>
					<h2>Класс Dog</h2>
					<pre>
						<code class="cs">
// Описание класса Dog
class Dog
{
	// Поля этого класса
	public string name;
	public string breed;
	public int age;
	public string owner;

	// Открытый метод 
	public void Walk()
	{
		Console.WriteLine("The {0} walks!", this.name);
		Random randGen = new Random();
		int rndNumber = randGen.Next(4);
		if (rndNumber == 3)
		{
			this.Pee();
		}
	}

	// Скрытый метод
	private int Pee()
	{
		Console.WriteLine("The {0} has urinated..", this.name);
		Random randGen = new Random();
		int strenth = randGen.Next(1, 11);
		return strenth;
	}
}

static void Main(string[] args)
{
	// Создание экземпляра класса Dog с именем dg1
	Dog dg1 = new Dog();
	// Присваивание значений полям
	dg1.name = "Альфред";
	dg1.breed = "Бернский зенненхунд";

	// Создание массива под 4 объекта класса Dog 
	Dog[] flock = new Dog[4];

	// Во второй элемент массива записываем ранее созданный объект
	flock[2] = dg1;

	// Вызываем для него метод Walk
	flock[2].Walk();
}					
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Ключевое слово <span class="blue">this</span></h1>
				<blockquote>
					Для доступа к членам текущего экземпляра класса можно использовать 
					ключевое слово <span class="blue">this</span>. Это ключевое 
					слово предоставляет ссылку на текущий объект класса. 
				</blockquote>
				<p>
					(В принципе, использовать <span class="blue">this</span> не обязательно, 
					но это бывает нужно при совпадении имен). Например:
				</p>
				<pre>
					<code class="cs">
// Допишем новый метод ChangeOwner
// который принимает параметр: строку owner
public bool ChangeOwner(string owner)
{
	// Сравниваtтся поле owner в текущем (this) объекте класса со значением параметра owner
	if (this.owner == owner)
	{
		return false;
	}
	// В поле записывается значение из параметра
	this.owner = owner;
	return true;
}
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h1>Спецификаторы доступа</h1>
					<p>
						Уровнем доступности каждого элемента класса можно управлять.
						Это делается с помощью <span class="purple">спецификаторов доступа</span>:
					</p>
					<blockquote>
						<ul>
							<li>public - общедоступный член класса</li>
							<li>private - член класса доступен только внутри данного класса</li>
							<li>protected - член класса доступен только внутри данного класса и его производных классов</li>
							<li>internal - член класса доступен только внутри данной сборки (~программы)</li>
						</ul>
					</blockquote>
				</section>
				<section>
					<h2>Класс Book</h2>
					<pre>
						<code class="cs">
// Описание класса Book
class Book
{
	// Открытые поля
	public string name;
	public string author;
	public int year;
	
	// Закрытые поля
	protected int id;
	private bool isAllowed;
		
	// Метод
	public void CreateEmptyBook()
	{
		// Всем полям задаются какие-то значения
		this.name = "неизвестно";
		this.author = "неизвестно";
		this.year = 0;   
		this.id = 0x8FFA;
		this.isAllowed = false;
	}
	
	// Метод 
	public void FillBook(string name, string author, int year)
	{
		// Заполнение полей через параметры
		this.name = name;
		this.author = author;
		this.year = year;
		this.id = 0x031AE;
		this.isAllowed = true;
	}
		
	// Метод
	public void GetInformation()
	{
		if (this.name == null)
		{
			// В методе вызывается другой метод
			this.CreateEmptyBook();
		}
		Console.WriteLine($"Книга '{name}' (автор {author}) была издана в {year} году");
	}   
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h1>Содержимое класса</h1>
					<p>
						Всё, что может быть внутри класса подразделяется на:
					</p>
					<ul>
						<li>Элементы данных</li>
						<li>Функциональные элементы</li>
						<li>Вложенные типы</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Элементы данных в классах</h2>
					<p>
						Элементы данных подразделяются на:
					</p>
					<ul>
						<li><b>поля</b></li>
						<li><small>константы</small></li>
						<li><small>события</small></li>
					</ul>
					<blockquote>
						Поле - основной член класса - переменная внутри класса, содержащая некоторое значение.
					</blockquote>
				</section>
				<section>
					<h3>Пример</h3>
					<blockquote>
						Можно, например, объявить класс, членами которого будут являться только поля:
					</blockquote>
					<pre>
						<code class="cs">
// Просто класс с полями
class SimpleClass
{
	public int x;
	public float y;
	public const double z = 0.9134;
	public const char c = 'A';
	public string s;
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Константы</h2>
					<p>
						Константы - это неизменяемые поля. Объявляются с помощью ключевого
						слова <span class="blue">const</span>
					</p>
					<pre>
						<code class="cs">
class Calendar1
{
	// Константное поле
	public const int months = 12;
}
						</code>
					</pre>
					<p>
						Константа не может быть объявлена без указания значения.
					</p>
				</section>
				<section>
					<h2>Поля только для чтения</h2>
					<p>
						Readonly поля - похожие на константы поля, с той лишь особенностью,
						что значение им может быть присвоенно отложенно (не сразу). Но после
						инициализации, менять их, так же как и константы, нельзя. Объявляются
						с помощью ключевого слова <span class="blue">readonly</span>.
					</p>
					<pre>
						<code class="cs">
class Age
{
	// Поле только для чтения
	readonly int year;

	// Метод
	void Initialize(int year)
	{
		// Записываем значение в поле только для чтения
		// Будет работать только один раз
		this.year = year;
	}

}

static void Main()
{
	Age a = new Age();
	a.Initialize(1974);		// ОК
	Console.WriteLine(a.year);
	a.Initialize(1967);		// Ошибка
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h1>Функциональные элементы в классах</h1>
					<p>
						Функциональные элементы подразделяются на:
					</p>
					<ul>
						<li><b>Методы</b></li>
						<li>Свойства</li>
						<li>Конструкторы</li>
						<li>Финализаторы</li>
						<li>Индексаторы</li>
						<li>Операторы</li>
					</ul>
				</section>
				<section>
					<h2>Методы</h2>
					<blockquote>
						Основой любого класса являются <span class="purple">методы</span> - функции 
						внутри класса, выполняющие какие-либо действия над полями этого класса.
					</blockquote>
					<p>
						Например здесь описаны два метода: Sum и Sub:
					</p>
					<pre>
						<code class="cs">
// Класс
class Calculator
{
	// Закрытые поля класса
	private int x;
	private int y;

	// Метод для подсчёта суммы значений этих полей
	public int Sum()
	{
		return this.x + this.y;
	}

	// Метод для подсчёта разности значекний этих полей
	public int Sub()
	{
		return this.x - this.y;
	}
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h1>Статические члены класса</h1>
					<blockquote>
						Обычные методы и вообще всё, описанное внутри класса, существует в контексте 
						какого-либо объекта этого класса. Т.е. для каждого экземпляра класса действуют свои копии 
						методов и полей.
					</blockquote>
					<p>
						Можно создать элементы класса, которые будут относиться непосредственно к самому классу, а не к
						объектам. Такие элементы класса называется <span class="purple">статическими</span>, являются
						общими для всех объектов и существуют в единственном экземпляре.
					</p>
					<p>
						Чтобы объявить такой элемент, нужно к его описанию добавить
						ключевое слово <span class="blue">static</span>.
					</p>
				</section>
				<section>
					<h2>Статические методы</h2>
					<p>
					Например, как происходит работа с консолью в c#?
						Что-то наподобие:
					</p>
					<pre>
						<code class="cs">
Console.WriteLine("message");
string input1 = Console.ReadLine();
Console.Write("end;\n");
						</code>
					</pre>
					<p>
						Обратите внимание, здесь нигде не создается объект класса 
						<span class="turquoise">Console</span>, 
						мы напрямую обращаемся с именем класса.
					</p>
					<p>
						Именно так используются статические методы.
					</p>
				</section>
				<section>
					<h3>Пример</h3>
					<p>
						Посмотрим на различия между вызовом статических и обыкновенных методов:
					</p>
					<pre>
						<code class="cs">
// Класс
class MinMax
{
	// Статический метод 
	public static int Min(int x, int y)
	{
		int z = (x &lt; y) ? x : y; // Тернарный оператор
		return z;
	}

	// Обычный метод
	public int Max(int x, int y)
	{
		int z = (x &gt; y) ? x : y;
		return z;
	}
}

class Progrma
{
	static void Main(string[] args)
	{
		int a = -2;
		int b = 23;
		Console.WriteLine("a={0}, b={1}", a, b);
		// Вызов статического метода
		// для класса MinMax
		int k = MinMax.Min(a, b);		
		Console.WriteLine("Min = {0}", k);
		
		MinMax instance = new MinMax();
		// Вызов обычного метода
		// для объекта instance класса MinMax
		instance.Max(a, b);			
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Область применения статики</h2>
					<blockquote>
						Статические методы применяются повсеместно,
						и используются в тех случаях, когда пользователю 
						нет необходимости создавать объект для работы с этим методом.
					</blockquote>
					<p>
						Статическими, например, могут быть какие-нибудь константы 
						внутри класса, общие для всех объектов. Или методы, никак не 
						затрагивающие всей основной структуры класса и работающие обособленно.
					</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Свойства</h2>
					<blockquote>
						Для создания большей гибкости и безопасности внутренних полей, были разработаны такие 
						элементы класса как <span class="purple">Свойства</span>. 
					</blockquote>
					<p>
						Во многих языках программирования свойствами называют 
						обычные поля класса, но в C# есть разграничение между этими понятиями.
						Хотя, фактически, они очень схожи между собой и имеют границу только для разработчика класса.
					</p>
				</section>
				<section>
					<h2>Свойства в C#</h2>
					<p>
						Свойством в C# называются специальные методы доступа (чтения/записи) к полю класса  
						(<span class="blue">get</span> и <span class="blue">set</span>).
					</p>
					<p>
						Описание свойства имеет следующий синтаксис:
					</p>
					<pre>
						<code class="cs">
// Закрытое поле
private int name;

// Открытое свойство для этого поля
public int Name
{
	// Геттер - чтобы получить значение
	get
	{
		return this.name;
	}
	// Сеттер - чтобы присвоить значение
	set
	{
		this.name = value; // value - специальное ключевое слово, описывающее присваевоемое значение
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Описание свойства</h2>
					<p>
						Свойство состоит из двух частей: 
					</p>
					<ul>
						<li>Метод-аксессор (геттер) <span class="blue">get</span></li>
						<li>Метод-аксессор (сеттер) <span class="blue">set</span></li>
					</ul>
					<p>
						Метод <span class="blue">get</span> обязательно должен возвращать значение.
					</p>
					<p>
						В методе <span class="blue">set</span> существует неявный параметр
						<span class="purple">value</span>, в котором хранится присваиваемое значение. 
					</p>
				</section>
				<section>
					<h3>Работа со свойствами</h3>
					<p>
						Поле и связанное с ним свойство - разные элементы, поэтому должны иметь разные имена.
					</p>
					<p>
						Общепринято называть Свойство так же как называется Поле, только с заглавной буквы.
					</p>
					<p>
						Работа со свойствами аналогична работе с обычными полями.
					</p>
					<pre>
						<code class="cs">
// Класс
class TimePeriod
{
	// Закрытое поле
	private double minutes;

	// Свойство для него
	public double Minutes
	{
		get { return this.minutes; }
		set { this.minutes = value; }
	}

	// Ещё одно закрытое поле
	private double hours;

	// И для второго поля свойство
	public double Hours
	{
		get { return this.hours; }
		set { this.hours = value; }
	}

}

static void Main()
{
	// Создаём экземпляр класса TimePeriod
	TimePeriod t = new TimePeriod();
	// В открытое свойство записываем значение
	t.Hours = 2;
	// Значения через свойства попадают в закрытые поля
	t.Minutes = 34;
	// Обращаемся к свойствам для получения значений
	Console.WriteLine("Время: {0} часов {1} минут", t.Hours, t.Minutes);
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Предназначение</h2>
					<p>
						Поля в классе принято всегда делать приватными, т.е. скрытыми.
					</p>
					<p>
						И для того, чтобы предоставить доступ к полю, используется Свойство
						 - публичный элемент, через который пользователь читает (get) или записывает (set)
						 значения в приватное поле.
					</p>
					<p>
						Т.е. свойство является посредником между пользователем и данными, 
						и когда нужно обращаться к полю всегда нужно делать это через свойство.
					</p>
					<p>
						В свойствах можно описывать необходимою логику или форматирование для значений.
					</p>
				</section>
				<section>
					<h2>Доступ только для чтения/записи</h2>
					<p>
						Один из акссессоров можно опускать.
					</p>
					<p>
						Если написать Свойство только с методом <span class="blue">get</span>, то
						свойство будет только для чтения: из него можно будет получить значение, а записать
						нельзя.
					</p>
					<p>
						И иенее распространённый вариант, с одним методом <span class="blue">set</span>,
						свойство будет только для записи: в него можно записывать значение, но нельзя получать.
					</p>
				</section>
				<section>
					<h2>Только чтение</h2>
					<p>
						Такой вариант свойства применяется довольно часто:
					</p>
					<pre>
						<code class="cs">
// Класс Person
public class Person
{
	// Закрыте поля
	private string firstName;
	private string lastName;
	private int age;
	
	// Метод для инициализации значений полей
	public void CreatePerson(string first, string last, int age)
	{
		this.firstName = first;
		this.lastName = last;
		this.age = age;
	}

	// Свойство только для получения значения
	// причём выдаваемое и хранимые значения различаются
	public string Name
	{
		get
		{
			return this.firstName + " " + this.lastName;
		}
	}

	// Обычное свойство
	public int Age
	{
		get
		{
			return this.age;
		}
	}

}
						</code>
					</pre>
				</section>
				<section>
					<h3>Примеры</h3>
					<pre>
						<code class="cs">
// Класс SomeClass
class SomeClass
{
	// Закрытое поле и открытое свойство для него
	private int mode;
	public int Mode
	{
		get { return this.mode; }
		set { this.mode = value; }
	}
	
	// Закрытое поле и открытое свойство для него
	private string name;
	public string Name
	{
		get { return this.name; }
		set { this.name = value; }
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Примеры</h3>
					<p>
						Вместо того, чтобы опускать аксессор, можно описать его как приватный:
					</p>
					<pre>
						<code class="cs">
// Класс Person
class Person
{
	// Ничего необычного
	private string name;
	public string Name
	{
		get { return name; }
		set { name = value; }
	}

	// Закрытое поле
	private char gender;
	// Открытое свойство
	public char Gender
	{
		// Обычный геттер
		get { return gender; }

		// Закрытый сеттер - доступен только внутри класса
		private set { gender = value; }
	}

	private DateTime birth;
	// Свойство без сеттера вовсе
	public DateTime Birth
	{
		get { return birth; }
	}

	// Снаружи между этими двумя вариантами разницы не будет никакой - ни там, ни там нет сеттара.
	// Но внутри, в первом случае, сеттер будет работать, а во втором - нет
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойства со встроенной проверкой</h3>
					<p>
						При необходимости, внутри свойства можно задавать какие-нибудь проверки,
						или в принципе писать любой нужный код.
					</p>
					<pre>
						<code class="cs">
// Ещё один класс
class TryPerson
{
	// Закрытое поле
	private string name;
	// Открытое свойство для него
	public string Name
	{
		// Геттер с логикой
		get
		{
			// Выдаёт не просто значение из поля, но с припиской "Name is "
			string res = "Name is " + this.name;
			return res;
		}
		// Сеттер с логикой
		set
		{
			// Записывает значение только если оно не равно пустой строке или нулевой ссылке
			if (value != "" &amp;&amp; value != null)
				name = value;
		}
	}

	private char gender;
	public char Gender
	{
		get { return gender; }
		// Закрытый сеттер с логикой
		private set
		{
			// Разрешает записывать только значения "м" и "ж"
			if (value == "м" || value == "ж")
				gender = value;
		}
	}

	private DateTime birth;
	public DateTime Birth
	{
		get { return birth; }
		// Без сеттера
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Примеры</h3>
					<pre>
						<code class="cs">
// Да сколько можно
public class Date
{
	// Закрытое поле с начальным значением (вообще, так лучше не делать)
	private int month = 7;

	// Открытое свойство для этого поля
	public int Month
	{
		// Стандартный геттер
		get
		{
			return this.month;
		}
		// Сеттер с логикой
		set
		{
			// Не пропускает значения вне диапазона номеров месяцев
			if ((value &lt; 0) && (value &lt; 13))
			{
				this.month = value;
			}
		}
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Примеры</h3>
					<p>
						Свойство (как и всё остальное) может быть статическим. Тогда оно может
						ссылаться только на статические поля:
					</p>
					<pre>
						<code class="cs">
// Остановитесь, классы!
public class Employee
{
	// Открытое статическое поле
	public static int NumberOfEmployees;
	// Закрытое статическое поле
	private static int counter;
	
	// Закрытое обычное поле
	private string name;

	// Свойство для него
	public string Name
	{
		get { return name; }
		set { name = value; }
	}

	// Статическое свойство для статического класса
	public static int Counter
	{
		get { return counter; }
		// Без сеттера
	}

	// Конструктор(?)
	public Employee()
	{
		// Увеличение счётчика рабочих
		counter = ++NumberOfEmployees;
	}
}

class TestEmployee
{
	static void Main()
	{
		// Записываем значение в открытое статическое поле класса Employee
		Employee.NumberOfEmployees = 107;

		// Создаём объект класса Employee
		Employee e1 = new Employee();
		// Записывае значение в его свойство
		e1.Name = "Claude Vige";

		// Выводим значение из статического свойства класса
		System.Console.WriteLine("Employee number: {0}", Employee.Counter);
		// и из свойства объекта
		System.Console.WriteLine("Employee name: {0}", e1.Name);
	}
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h1>Конструкторы</h1>
					<blockquote>
						<span class="purple">Конструктор</span> - особый метод, вызываемый при создании экземпляра класса. Он 
						называется так же, как класс, и не имеет типа возвращаемого значения.
					</blockquote>
					<p>
						В классе всегда должен быть хотя бы один конструктор (если его нет - он
						создаётся неявно сам).
					</p>
					<p>
						Выделяют 4 основных типа конструкторов:
					</p>
					<ul>
						<li>Конструктор по умолчанию</li>
						<li>Конструктор с аргументами</li>
						<li>Конструктор копирования</li>
						<li>Статический конструктор</li>
					</ul>
				</section>
				<section>
					<h2>Конструктор по умолчанию</h2>
					<p>
						Конструктор, объявленный без аргументов, 
						называется конструктором по умолчанию и должен присутствовать в любом классе.
					</p>
					<p>
						Если не написать конструктор по умолчанию самостоятельно,
						компилятор создаст его на этапе компиляции.
					</p>
				</section>
				<section>
					<h3>Пример класса с конструктором</h3>
					<pre>
						<code class="cs">
// Класс без конструктора (явного)
class A
{
	// С открытыми полями
	public int x, y, z;
}

// Класс с конструктором
class B
{
	// С открытыми полями
	public int x, y, z;
	
	// Конструктор по умолчанию - без параметров
	public B()
	{
		// Инициализация полей
		x = 3;
		y = 4;
		z = 5;
	}
}

class Program
{
	public static void Main(string[] args)
	{
		// При создании объекта через new вызывается конструктор
		// Для класса A вызывается автоматически созданный конструктор по умолчанию, x = y = z = 0
		A a1 = new A();		
		// Для класса B вызывается написанный нами конструктор по умолчанию, x = 3, y = 4, z = 5
		B b1 = new B();
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Конструкторы с аргументами</h2>
					<blockquote>
						Конструкторы могут принимать различные аргументы, с помощью которых объекты классов 
						инициализируются разнообразными способами.
					</blockquote>
				</section>
				<section>
					<h3>Пример использования конструкторов с аргументами</h3>
					<pre>
						<code class="cs">
// Класс D
class D
{
	// Открытые поля
	public int x, y, z;

	// Конструктор по умолчанию
	public D()
	{
		// Инициализация всех полей
		x = y = z = 0;
	}

	// Конструктор с двумя параметрами
	public D(int x, int y)
	{
		// Инициализация всех полей
		this.x = x;
		this.y = y;
		this.z = x + y;
	}

	// Конструктор с тремя параметрами
	public D(int x, int y, int z)
	{
		// Инициализация всех полей
		this.x = x;
		this.y = y;
		this.z = z;
	}
}

class Program
{
	public static void Main(string[] args)
	{
		// Создаём объект класса D используя конструктор по умолчанию, x = y = z = 0
		D did = new D();
		// Создаём объект класса D используя конструктор с 2 параметрами, x = 5, y = 8, z = 13
		D opo = new D(5, 8);
		// Создаём объект класса D используя конструктор с 3 параметрами, x = 7, y = 2, z = 6
		D fer = new D(7, 2, 6);
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Конструктор копирования</h2>
					<blockquote>
						Конструктор копирования принимает в качестве 
						параметра экземпляр своего класса, и нужен затем, чтобы 
						создать текущий объект как копию переданного.
					</blockquote>
					<pre>
						<code class="cs">
// Очередной класс
class ClassC
{
	// Три открытых поля
	public int x, y, z;

	// Конструктор по умолчанию
	public ClassC() 
	{
		// Инициализирует все поля значением -1
		x = y = z = -1; 
	}

	// Конструктор копирования
	public ClassC(ClassC obj_c)
	{
		// Копирует все данные из объекта, переданного параметром obj_c, в текущий объект this 
		this.x = obj_c.x;
		this.y = obj_c.y;
		this.z = obj_c.z;
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Применение конутруктора копирования</h3>
					<blockquote>
						Необходимость в конструкторе копирования обуславливается тем, что класс является объектом ссылочного типа, 
						а это означает, что после операции присваивания между двумя объектами класса произойдет копирование ссылки 
						на один и тот же объект, а не создание объекта-копии. 
					</blockquote>
					<pre>
						<code class="cs">
// Создаём объект класса ClassC obj1
ClassC obj1 = new ClassC();
// Здесь не создаётся новый объект obj2
ClassC obj2 = obj1;		
// obj1 и obj2 указывают на один и тот же объект класса

obj2.x = -10;		// obj1.x == -10

// А вот здесь создаётся новый объект - копия объекта obj2
ClassC obj3 = new C(obj2);
// obj3 имеет такие же значения полей как и obj2, но является другим объектом

obj3.x = 2000;		// obj2.x == -10
						</code>
					</pre>
				</section>
				<section>
					<h2>Статический конструктор</h2>
					<p>
						Статический конструктор используется для инициализации статических 
						элементов класса, и не может иметь параметров. Он неявно вызывается средой CLR
						сам, до момента первого использования класса.
					</p>
					<pre>
						<code class="cs">
// Класс
class SimpleClass
{
	// Статическое поле только для чтения
	static readonly long baseline;

	// Статический конструктор
	static SimpleClass()
	{
		// Который инициализирует статическое поле
		baseline = DateTime.Now.Ticks;
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="cs">
// Класс
public class Bus
{
	// Статическая переменная используемая всеми экземплярами класса Bus
	// Представляет время, когда первый за день автобус начал свой маршрут 
	protected static DateTime globalStartTime;

	// Свойство для номера маршрута каждого автобуса
	// Сокращённая форма записи
	protected int RouteNumber { get; set; }	

	// Статический конструктор инициализирует статическое поле
	// Это происходит до создания первого экземпляра класса
	static Bus()
	{
		globalStartTime = DateTime.Now;

		Console.WriteLine("Статический конструктор установил время старта на {0}",
			globalStartTime.ToLongTimeString());
	}

	// Конструктор экземпляра класса
	public Bus(int routeNum)
	{
		RouteNumber = routeNum;
		Console.WriteLine("Автобус #{0} отправляется в путь.", RouteNumber);
	}

	// Метод экземпляра класса
	public void Drive()
	{
		TimeSpan elapsedTime = DateTime.Now - globalStartTime;

		// Симуляция времени поездки автобуса
		Console.WriteLine("Автобус {0} начал своё движение через {1:N2} минут после общего времени старта {2}.",
			this.RouteNumber,
			elapsedTime.Milliseconds,
			globalStartTime.ToShortTimeString()
		);
	}
}

class TestBus
{
	static void Main()
	{
		// Создание экземпляра предварительно активирует статический конструктор.
		Bus bus1 = new Bus(71);

		// Создание второго маршрута
		Bus bus2 = new Bus(72);

		// Автобус 1 отправляется в путь
		bus1.Drive();

		// Делаем паузу перед отправкой второго автобуса
		System.Threading.Thread.Sleep(25);

		// Автобус 2 отправляется
		bus2.Drive();

		System.Console.WriteLine("Нажмите любую клавишу для выхода...");
		System.Console.ReadKey();
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Рекомендации</h2>
					<blockquote>
						Для любого класса желательно всегда опеределять конструктор 
						по умолчанию и конструктор копирования, так как они являются 
						универсальными и могут требоваться некоторыми встроенными алгоритмами.
					</blockquote>
				</section>
			</section>
			<section>
				<section>
					<h1>Финализатор</h1>
					<blockquote>
						Финализатор - специальный метод, который вызывается перед тем, 
						как Сборщик Мусора соберется удалить ваш объект. Он должен называться
						так же, как и сам класс, только перед именем должен стоять знак тильды ~.
					</blockquote>
					<pre>
						<code class="cs">
class Car
{
	// Финализатор
	~Car() 
	{
		// Освобождаем ресурсы...
		// Прощаемся с объектом...
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример работы финализатора</h3>
					<pre>
						<code class="cs">
// Класс
class FinalizeObject
{
	// Свойство и поле в сокращённой форме записи
    public int Id { get; set; }

	// Открытое статическое поле
    public static int identity;

	// Статический конструктор
	static FinalizeObject()
	{
		// Присваиваем начальное значение статическому полю
		identity = 0;
	}

	// Конструктор по умолчанию
    public FinalizeObject()
    {
		// Присваиваем полю текущего объекта значение из статического поля
		this.Id = FinalizeObject.identity++;
		// Затем увеличиваем значение в статическом поле на 1
		// Таким образом, Id каждого последующего создавающегося объекта будет на 1 больше,
		// чем у предыдуще созданного объекта
    }

	// Финализатор
    ~FinalizeObject()
    {
		// Перед удалением объекта из памяти, на консоль выведется его Id
        Console.WriteLine("Объект №{0} уничтожен", Id);
    }
}

class Program
{
    static void Main(string[] args)
    {
		// Создаётся массив для 100 экземпляров класса FinalizeObject
		FinalizeObject[] obj = new FinalizeObject[100];
		// По циклу создаём эти 100 объектов
        for (int i = 0; i &lt; 100; i++)
			obj[i] = new FinalizeObject();
			
		// Main заканчивается, и все переменные, созданные в нём удаляются
		// Т.е. удаляются и наши экземпляры класса
    }
}
					</code>
				</pre>
			</section>
		</section>
		<section>
			<section>
				<h2>Индексаторы</h2>
				<blockquote>
					Индексаторы позволяют обращаться с объектом класса так, как будто он является массивом,
					т.е. применять оператор квадратных скобок.
				</blockquote>
				<p>
					Индексатор по синтаксису напоминает свойство. Он также состоит из методов-аксессоров
					get и set, только в дополнение принимает параметр - индекс.
				</p>
				<pre>
					<code class="cs">
// Пример индексатора 
public тип_возвращаемого_значения this[тип_индекса j] // Принимает "параметр" - индекс
{
	get 
	{ 
		// Действия с return 
	}
	set
	{
		// Установка значения c value
	}
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Индексатор в классе</h2>
				<p>
					Обычно индексаторы используются в классах, которые содержат массив или другую 
					коллекцию, для простого доступа к их элементам.
				</p>
				<pre>
					<code class="cs">
// Класс
class MyArray
{
	// Приватное поле - массив байт
	private byte[] innerArr = new byte[100];

	// Индексатор к текущему классу, для доступа к элементам закрытого массива
	public byte this[int i]
	{
		// Геттер, возвращающий элемент массива по переданному индексу i
		get
		{
			return arr[i];
		}
		// Сеттер, записывающий значение в элемент массива по индексу i
		set 
		{
			arr[i] = value;
		}
	}
}

class Program
{
	static void Main()
	{
		// Создаём экземпляр класса MyArray
		var arr = new MyArray();

		// Записываем значение 255 по индексу 0 во внутреннее поле-массив класса через индексатор
		arr[0] = 255;

		// Обращаемся к нулевому элементу массив через индексатор
		Console.WriteLine(arr[0]);
	}
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Несколько индексаторов</h2>
				<p>
					Как и методы, индексаторы могут быть перегружены. Т.е. в одном классе может быть
					сразу несколько индексаторов, различающихся типами индексов и их количеством.
				</p>
				<pre>
					<code class="cs">
// Класс Human
class Human
{
	// Закрытые поля
	protected string name;
	protected string surname;
	protected string patronymic;

	// Индексатор с типом параметра string
	public string this[string s]
	{
		// Возвращает значение поля класса по переданному имени поля
		get
		{
			switch (s)
			{
				case "name": return this.name;
				case "surname": return this.surname;
				case "patronymic": return this.patronymic;
				default: return "none";
			}
		}
		// Записывает значение в поле, по переданному имени
		set
		{
			switch (s)
			{
				case "name": this.name = value; break;
				case "surname": this.surname = value; break;
				case "patronymic": this.patronymic = value; break;
			}
		}
	}

	// Индексатор для текущего класса с типом параметра int
	public string this[int n]
	{
		// Каждое поле класса ассоциированно с индексом-числом
		// В зависимости от числа в индексе, позвращаем значение из какого-либо поля
		get
		{
			switch (n)
			{
				case 0: return this.name;
				case 1: return this.surname;
				case 2: return this.patronymic;
				default: return "none";
			}
		}
		// То же самое, только с присваиванием значения
		set
		{
			switch (n)
			{
				case 0: this.name = value; break;
				case 1: this.surname = value; break;
				case 2: this.patronymic = value; break;
			}
		}
	}
}

public class BlaBlaClass
{
	public static void Main(string[] args)
	{
		// Создание объекта класса Human 
		Human slave1 = new Human();
		// Обращение к объекту через индексатор принимающий строку
		slave1["name"] = "Gregore";
		// Записываем значения в поля, обращаясь к ним через квадратные скобки
		slave1["surname"] = "O'Cammel";
		slave1["patronymic"] = "What does it mean?";

		// Или так, используя второй индексатор, который принимает индексы - числа
		slave1[2] = "Silence!"

		// Можно перебрать свойства через цикл
		for (int i = 0; i &lt; 3; ++i)
		{
			Console.WriteLine($"Field #{i, 2}: {slave1[i]}");
		}
	}
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Индексаторы с несколькими индексами</h2>
				<p>
					Индексатор может принимать не только один индекс, но и сразу несколько, как при
					использовании многомерных массивов.
				</p>
				<pre>
					<code class="cs">
// Класс ячейки шахматного поля
class ChessBoardCell
{
	// ...

}
// Класс шахматной доски
class ChessBoard
{
	// Закрытое поле для хранения информации о клетках поля
	// Двумерный массив 8х8 из объектов класса CheshBoardCell
	private CheshBoardCell[,] _matrix = new ChessBoardCell[8, 8];

	// Индексатор с двумя индексами - символом и числом
	public int this[char row, int column]
	{
		// Из символа получаем число, соответствующее индексу во внутренней матрице
		// И по полученному числу и второму индексу возвращаем значение
		get
		{
			if ((int)row &gt;= (int)'A' && (int)row &lt;= (int)'h')
			{
				return _matrix[(char)((int)row - (int)'A'), column];
			}
			else if ((int)row &gt;= (int)'a' && (int)row &lt;= (int)'h')
			{
				return _matrix[(char)((int)row - (int)'a'), column];
			}
			else
			{
				return CheshBoardCell.WrongCell;
			}
		}
		// То же самое, только с присваиванием значения
		set
		{
			if ((int)row &gt;= (int)'A' && (int)row &lt;= (int)'h')
			{
				_matrix[(char)((int)row - (int)'A'), column] = value;
			}
			else if ((int)row &gt;= (int)'a' && (int)row &lt;= (int)'h')
			{
				_matrix[(char)((int)row - (int)'a'), column] = value;
			}
		}
	}
}

// Перечисление игровых сторон
enum ChessSide
{ 
	WHITE, 
	BLACK 
};

// Перечисление видов шахматных фигур
enum ChessPieceType
{
	KING,
	QUEEN,
	BISHOP,
	KNIGHT,
	ROOK,
	PAWN
}

// Класс для шахматной фигуры
class ChessPiece
{
	// ...

}

class Program
{
	public static void Main(string[] args)
	{
		// Создаём объект класс ChessBoard
		ChessBoard board = new ChessBoard(true);

		// Через индексатор по 2 индексам обращаемся к определённой ячейке массива и записываем в неё значение
		board['E', 1] = new ChessPiece(ChessSide.WHITE, ChessPieceType.ROOK);
		board['E', 2] = new ChessPiece(ChessSide.WHITE, ChessPieceType.PAWN);

		// Получаем значение через индексатор по 2 индексам
		ChessPiece myKnight = board['G', 5];

	}

}
					</code>
				</pre>
			</section>
		</section>
		<section>
			<h2>Документация</h2>
			<p>
				Подробно обо всём можно почитать в
				<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/">документации</a>.
			</p>
		</section>
		</div>
	</div>
	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
    <aside id="presentable-icon-close">
        <a title="К списку материалов" href="../../index.html">
            <i class="fa fa-times fa-2x"></i>
        </a>
    </aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>