<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Object-oriented programming</title>
	<meta name="description" content="programming paradigm OOP in C#, concept of classes and objects, attributes and methods">
	<meta name="keywords" content="c#, oop, class, object, interface">
	<meta name="author" content="Edward & Albert">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Объектно-ориентированное программирование</h1>
                    <h3>Операторы</h3>
                    <p>
                        <small>Edward &amp; Albert / <a href="https://github.com/tgjmjgj/sharp/">github:Tgjmjgj</a></small>
                    </p>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
            <section>
                <section>
                    <h2>Задача</h2>
                    <p>
                        Представьте, что вам нужно реализовать класс для каких-нибудь своих числовых значений.
                    </p>
                    <p>
                        Пусть это будут числа алгебры Паши, где не существует числа 5, а операции сложения и
                        вычитания не совсем коммутативны.
                    </p>
                    <pre>
                        <code class="cs">
class PInt
{
    private int num;
}
                        </code>
                    </pre>
                    <p>
                        Как реализовать операции над ним? Самый очевидный ответ - через методы.
                    </p>
                </section>
                <section>
                    <h2>Класс PInt</h2>
                    <p>
                        Например, вот так:
                    </p>
                    <pre>
                        <code class="cs">
// Класс Числа Пашиной алгебры (П-числа)
class PInt
{
    // Приватное поле для хранения числа
    private int num;

    // Конструктор
    public PInt(int init)
    {
        num = init;
        // Если число кратно 5, увеличиваем его на единицу
        if (num % 5 == 0)
        {
            ++num;
        }
    }

    // Метод Plus для сложения двух П-чисел
    public PInt Plus(PInt p2)
    {
        // Считаем количество пятерок во втором числе
        int numberOfFives = p2.num / 5;
        // Прибавляем к первому числу второе за исключением количества пятерок в нём
        num += p2.num - numberOfFives;
        // Если число кратно пяти
        if (num % 5 == 0)
        {
            // Увеличиваем на 1
            ++num;
        }
        return this;
    }

    // Метод Minus для получения разности двух П-чисел
    public PInt Minus(PInt p2)
    {
        // Считаем количество пятерок во втором числе
        int numberOfFives = p2.num / 5;
        // Отнимаем от первого числа второе за исключением количества пятерок в нём
        num -= p2.num - numberOfFives;
        // Если число кратно пяти
        if (num % 5 == 0)
        {
            // Уменьшаем на 1
            --num;
        }
        return this;
    }

    // Переопределение метода ToString для вывода числа на консоль с суффиксом 'p'
    public override string ToString()
    {
        return num.ToString() + "p";
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Использование класса PInt</h2>
                    <pre>
                        <code class="cs">
static void Main(string[] args)
{
    // Создаём три числа
    PInt p1 = new PInt(245);
    PInt p2 = new PInt(141);
    PInt p3 = new PInt(-300);

    // Выполняем математические операции
    p1 = p1.Plus(p2).Plus(p3);
    p2 = p1.Minus(p3);
}
                        </code>
                    </pre>
                    <p>
                        Выглядит очень громоздко. А если ещё нужно добавить операции умножения, деления,
                        возведения в степень и т.д. 
                    </p>
                </section>
                <section>
                    <h2>Операции</h2>
                    <p>
                        Гораздо лучше было бы работать с нашими объектами, как с обыкновенными числами:
                    </p>
                    <pre>
                        <code class="cs">
// Создавать так:
PInt p1 = 245;
// А не так:
PInt p1 = new PInt(245);

// Складывать так:
p2 = p1 + p3;
// А не так:
p2 = p1.Plus(p3);

// Вычитать так:
p3 = p1 - p1;
// А не так:
p3 = p1.Minus(p1);
                        </code>
                    </pre>
                    <p>
                        И этого можно добиться с использованием <span class="purple">перегрузки операторов</span>.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h1>Перегрузка операторов</h1>
                    <blockquote>
                        <span class="purple">Перегрузка операторов</span> - создание логики поведения при
                        использовании стандартных операторов языка над объектами произвольных классов. 
                    </blockquote>
                    <p>
                        Напомним, что операторы - это символы операций (+, -, ==, !=, &lt;, &gt;, ^, | и т.д.).
                    </p>
                </section>
                <section>
                    <h2>Что имеется в виду</h2>
                    <pre>
                        <code class="cs">
// Создаём Мишу
Person person1 = new Person("Misha");
// Делим Мишу на 2 и получаем полурослика
Person halfling = person1 / 2;

// Если Миша больше полурослика
if (person1 > halfling)
{
    // Создаём Машу
    Person person2 = new Person("Masha");
    // Складываем Мишу и Машу и получаем ребёнка
    Person child = person1 + person2;

    // Если ребёнок равен Мише
    if (child == person1)
    {
        // Что-то пошло не так...
        Console.WriteLine("Something went wrong...");
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Операторы</h2>
                    <table>
                        <tr>
                            <th style="width: 45%;">Операторы</th>
                            <th style="width: 65%;">Перегружаемость</th>
                        </tr>
                        <tr>
                            <td>+, -, !, ~, ++, --, true, false</td>
                            <td>Можно перегружать</td>
                        </tr>
                        <tr>
                            <td>+, -, *, /, %, &, |, &lt;&lt;, &gt;&gt;</td>
                            <td>Можно перегружать</td>
                        </tr>
                        <tr>
                            <td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td>
                            <td>Можно перегружать, только парами</td>
                        </tr>
                        <tr>
                            <td>&&, ||</td>
                            <td>Нельзя, но они используют & и |</td>
                        </tr>
                        <tr>
                            <td>[]</td>
                            <td>Вместо перегрузки - индексаторы</td>
                        </tr>
                        <tr>
                            <td>()</td>
                            <td>Нельзя</td>
                        </tr>
                        <tr>
                            <td>+=, -=, *=, /=, %=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td>
                            <td>Перегружаются автоматически при перегрузке соответствующего бинарного оператора</td>
                        </tr>
                        <tr>
                            <td>=, ., ?:, ?., ??, ->, =>, f(x), new, is, as, checked, unchecked, default, delegate, sizeof, typeof, nameof</td>
                            <td>Нельзя</td>
                        </tr>
                    </table>
                </section>
            </section>
            <section>
                <section>
                    <h2>Синтаксис</h2>
                    <p>
                        Перегрузка оператора описывается в классе (или структуре), для которого она предназначена, и
                        выглядит практически как описание обычного статического метода:
                    </p>
                    <pre>
                        <code class="cs">
public static возвр_значение operator знак_оператора (аргументы);
                        </code>
                    </pre>
                    <p>
                        Вместо имени метода записывается специальное ключевое слово <span class="blue">operator</span>
                        и знак оператора, который нужно переопределить.
                    </p>
                </section>
                <section>
                    <h2>Аргументы</h2>
                    <p>
                        Минимум один из аргументов оператора должен быть того типа, для которого эта перегрузка создаётся.
                    </p>
                    <p>
                        У унарных операторов 1 аргумент, у бинарных - 2 аргумента.
                    </p>
                    <pre>
                        <code class="cs">
class Person
{
    // Перегруженный оператор + для класса Person
    // В качестве аргументов принимает 2 объекта типа Person
    // И возвращает объект типа Person
    public static Person operator +(Person first, Person second)
    {
        // Создаётся новая персона и возвращается
        return new Person();
    }
}

// Класс Игрок
class Player
{
    // Свойство Уровень
    public int Level { get; set; }

    // Перегруженный оператор инкремента ++ с одним параметром типа Player
    // С типом возвращаемого значения Person
    public static Player operator ++(Player p)
    {
        // Увеличиват значение свойства Уровень на 1
        p.Level++;
        // Возвращает объект, который принял
        return p;
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Как это работает</h2>
                    <p>
                        На самом деле, любой оператор в C# - это просто вот такой вот замаскированный метод.
                    </p>
                    <p>
                        Когда вы складываете 2 числа, и пишете:
                    </p>
                    <pre>
                        <code class="cs">
int a = 2;
int b = 3;
int c = a + b;
                        </code>
                    </pre>
                    <p>
                        Но на самом деле это происходит так, только скрыто от программиста:
                    </p>
                    <pre>
                        <code class="cs">
int c = Int32.operator+(a, b);
                        </code>
                    </pre>
                    <p>
                        Вызывается метод соответствующего оператора, а операнды передаются ему в качестве параметров.
                    </p>
                </section>
                <section>
                    <h3>Чуть глубже</h3>
                    <p>
                        На самом деле всё ещё серьёзнее, и выглядит примерно следующим образом:
                    </p>
                    <pre>
                        <code class="cs">
int a;
Int32.operator=(a, 2);
int b;
Int32.operator=(b, 3);
int c;
Int32.operator=(c, Int32.operator+(a, b));
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Person и Player</h3>
                    <p>
                        Значит, когда мы будем применять операторы для объектов классов, в которых они перегружены,
                        то просто будут вызываться соответствующие оператору методы этого класса.
                    </p>
                    <pre>
                        <code class="cs">
class Person
{
    // Перегруженный оператор + для Peroson и Person в классе Person
    public static Person operator +(Person first, Person second)
    {
        return new Person();
    }
}

class Player
{
    public int Level { get; set; }

    // Перегруженный оператор ++ в классе Player
    public static Player operator ++(Player p)
    {
        p.Level++;
        return p;
    }
}

class App
{
    static void Main(string[] args)
    {
        Person p1 = new Person();
        // Здесь неявно происходит вызов описанного нами метода operator+
        // Куда p1 передаётся в качестве аргумента first, и p1 в качестве аргумента second
        Person p2 = p1 + p1;
        // То же самое, только в качестве второго аргумента передаётся объект p2
        Person p3 = p1 + p2;

        Player pl = new Player();
        pl.Level = 1;

        // Неявно вызывается метод operator++, в качестве аргумента передаётся объект pl
        // pl.Level становится равен 2
        ++pl;
        // pl.Level становится равен 3
        pl++;
    }
}
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Перегрузка унарных операторов</h2>
                    <p>
                        Унарные операторы можно разделить на 3 группы:
                    </p>
                    <ul>
                        <li>+, -, !, ~</li>
                        <li>++, --</li>
                        <li>true, false</li>
                    </ul>
                    <p>
                        Эти группы операторов различаются ограничениями, которые
                        накладываются на их перегрузку.
                    </p>
                    <u>
                        У всех унарных операторов в качестве параметра должен быть объект
                        типа, в котором они перегружаются.
                    </u>
                </section>
                <section>
                    <h2>Операторы +, -, !, ~</h2>
                    <p>
                        Перегрузки этих операторов могут возвращать <u>любой тип</u>, за исключением void.
                    </p>
                    <pre>
                        <code class="cs">
// Класс комплексного числа                          
class Complex
{
    // Действительная часть
    private int a;
    // Мнимая часть
    private int b;

    public Complex()
    {
        a = b = 0;
    }

    public Complex(int i, int j)
    {
        a = i;
        b = j;
    }
    
    // Перегрузка оператора унарного минуса, возвращает объект такого же класса Complex
    public static Complex operator -(Complex c)
    {
        // Создаётся новое комплексное число
        Complex temp = new Complex();
        // Меняются знаки его компонент
        temp.a = -c.a;
        temp.b = -c.b;
        // Возвращается инвертированное комплексное число
        return temp;
    }

    // Перегрузка оператора Битового отрицания, возвращаемое значение - int
    public static int operator ~(Complex c)
    {
        // Возвращает действительную часть числа c
        return c.a;
    }

    // Перегрузка оператора Не, возвращаемое значение - bool
    public static bool operator !(Complex c)
    {
        // Возвращает true, если мнимая часть числа равна нулю, иначе возвращает false
        return c.b == 0 ? true : false;
    }

    // Заодно переопределён метод ToString
    public override string ToString()
    {
        // Чтобы в правильной форме отображать комплексное число
        return a + " + " + b + "i";
    }
}
class MyClient
{
    public static void Main()
    {
        // Создаём комплексное число 10 + 20i
        Complex c1 = new Complex(10, 20);
        Console.WriteLine(c1);
        // Неявно вызываем перегруженный метод оператора унарного минуса для объекта c1.
        // Полученное значение записываем в c2
        Complex c2 = -c1;
        Console.WriteLine(c2);

        // Неявно вызываем перегрузку оператора ~, чтобы получить действительную часть числа c2
        // Если она равна -10
        if (~c2 == -10)
        {
            // Неявно вызываем метод оператора !, чтобы проверить наличие мнимой части
            // Он возвращает true/false и мы можем использовать это в условии if-а
            if (!c2)
            {
                Console.WriteLine("У числа отсутствует мнимая часть");
            }
            else
            {
                Console.WriteLine("Число имеет мнимую часть");
            }
        }

    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Операторы ++, --</h2>
                    <p>
                        Перегрузка оператора инкремента/декремента автоматически распространяется как 
                        на постфиксную, так и на префиксную версию оператора.
                    </p>
                    <p>
                        Метод перегрузки этих операторов обязательно должен возвращать объект <u>того же типа,
                            в котором он объявлен</u>. 
                    </p>
                </section>
                <section>
                    <h3>Операторы ++, --</h3>
                    <pre>
                        <code class="cs">
// Класс Муравейника
class Anthill
{
    // Свойство Количество муравьёв 
    public int AntNumber { get; private set; }

    // Перегрузка оператора инкремента ++
    // Без вариантов: принимает Ants, возвращает Ants
    public static Anthill operator ++(Anthill ants)
    {
        // Увеличиваем количество муравьёв на 1
        ++ants.AntNumber;
        // Возвращаем то, что приняли
        return ants;
    }

    // То же самое по аналогии
    public static Anthill operator --(Anthill ants)
    {
        --ants.AntNumber;
        return ants;
    }

}

class Program
{
    static void Main(string[] args)
    {
        // Создаём объект муравейника
        Anthill ants = new Anthill();
        
        // По циклу увеличиваем их количество, пока оно не достигнет 100
        while (ants.AntNumber < 100)
        {
            ants++;
        }
    }
}                            
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Операторы true и false</h2>
                    <p>
                        Во-первых, представьте себе, есть такие операторы.
                    </p>
                    <p>
                        Во-вторых, они - парные. Это значит, что их можно перегружать только вместе. Если
                        написать один, но не написать другой, компилятор выдаст ошибку.
                    </p>
                    <p>
                        В-третьих, эти операторы должны всегда возвращать тип <span class="blue">bool</span>.
                    </p>
                    <p>
                        Оператор true вызывается, когда мы пытаемся использовать объект класса в условии if,
                        тернарном операторе или условии цикла.
                    </p>
                    <p>
                        А когда вызывается оператор false... Это мы узнаем чуть попозже.
                    </p>
                </section>
                <section>
                    <h2>Оператор true</h2>
                    <pre>
                        <code class="cs">
class Anthill
{
    public int AntNumber { get; set; }

    public static Anthill operator -- (Anthill ants)
    {
        --ants.AntNumber;
        return ants;
    }

    // Перегрузка оператора true. 
    // Принимает Anthill, возвращает bool. Иные типы не допустимы.
    public static bool operator true(Anthill ants)
    {
        Console.WriteLine("Operator true");
        // Возвращает true, если количество муравьёв больше нуля
        return ants.AntNumber > 0;
    }

    // По аналогии.
    // По своей сути операторы true и false должны быть противоположными
    // true проверяет объект на истинность, false - на ложность
    public static bool operator false(Anthill ants)
    {
        Console.WriteLine("Operator false");
        // Возвращает true, если количество муравьёв меньше или равно нулю
        return ants.AntNumber <= 0;
    }

}

class Program
{
    static void Main(string[] args)
    {
        Anthill anthill = new Anthill();
        anthill.AntNumber = 0;
        // Вот здесь вызовется оператор true
        // Поскольку количество муравьёв не больше нуля, метод оператора вернёт false
        if (anthill)
        {
            Console.WriteLine("Anthill inhabited");
        }
        else
        {
            // Следовательно, выполнится этот блок else
            Console.WriteLine("Anthill abandoned");
        }
        anthill.AntNumber = 3;
        // Здесь оператор true будет выполняться по циклу,
        // Пока не вернёт false и цикл не закончится
        while (anthill)
        {
            anthill--;
            Console.WriteLine("Ants left: {0}", anthill.AntNumber);
        }
    }
}
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Бинарные операторы</h2>
                    <p>
                        Бинарные операторы называются бинарными, потому что применяются к двум операндам,
                        значит принимают 2 параметра.
                    </p>
                    <p>
                        Поскольку мы описываем перегрузку для какого-либо конкретного класса, <u>хотя бы
                            один из 2 параметров должен быть этого типа</u>.
                    </p>
                    <p>
                        Тип возвращаемого значения - любой, кроме void.
                    </p>
                    <p>
                        После перегрузки оператора, автоматически появляется возможность использовать
                        операторы смешанного присваивания (оператор + присваивание). Т.е. если вы перегрузили
                        оператор бинарного +, то сможет использовать оператор +=.
                    </p>
                </section>
                <section>
                    <h2>Второй аргумент</h2>
                    <p>
                        Второй аргумент - самое интересное, что есть в перегрузке бинарных операторов.
                    </p>
                    <p>
                        Дело в том, что он может быть любого типа.
                    </p>
                    <p>
                        А это позволяет делать перегрузки перегрузок операторов.
                    </p>
                    <p>
                        Рассмотрим на примере бинарного оператора +, оператора сложения. Мы можем определить
                        в классе сколько нам потребуется перегрузок этого оператора, для разных типов второго аргумента.
                        Пусть будет возможность складывать объект нашего класса с числом, объект со строкой, два объект
                        друг с другом - любые варианты комбинаций.
                    </p>
                    <p>
                        Порядок аргументов у оператора имеет значение. Поэтому, обычно, если вы перегружаете "Класс + число",
                        то следует и перегрузить "Число + класс".
                    </p>
                </section>
                <section>
                    <h2>Числа Пашиной алгебра</h2>
                    <p>
                        Перепишем класс П-чисел, заменив в нём методы для сложения и вычитания на соответствующие операторы:
                    </p>
                    <pre>
                        <code class="cs">
// Всё тот же класс П-чисел
class PInt
{
    private int num;

    public PInt(int init)
    {
        num = init;
        if (num % 5 == 0)
        {
            ++num;
        }
    }

    public PInt(PInt p)
    {
        num = p.num;
    }

    // Вместо метода Plus - перегрузка оператора сложения
    // Возвращает PInt и принимает 2 значения типа PInt
    public static PInt operator +(PInt left, PInt right)
    {
        int numberOfFives = right.num / 5;
        PInt retP = new PInt(left.num);
        retP.num += right.num - numberOfFives;
        if (retP.num % 5 == 0)
        {
            ++retP.num;
        }
        return retP;
    }

    // Перегрузка оператора вычитания
    // Также возвращает PInt и принимает 2 значения PInt
    public static PInt operator -(PInt left, PInt right)
    {
        int numberOfFives = right.num / 5;
        PInt retP = new PInt(left.num);
        retP.num -= right.num - numberOfFives;
        if (retP.num % 5 == 0)
        {
            --retP.num;
        }
        return retP;
    }

    public override string ToString()
    {
        return num.ToString() + "p";
    }
}

class Program
{
    static void Main(string[] args)
    {
        PInt p1 = new PInt(245);
        PInt p2 = new PInt(141);
        PInt p3 = new PInt(-300);
        
        Console.WriteLine("{0} + {1} = {2}", p1, p2, p1 + p2);
        Console.WriteLine("{0} + {1} = {2}", p2, p1, p2 + p1);

        // Теперь можно складывать и вычитать PInt, как обычные числа
        p1 = p1 + p2 - p3;
        p2 = p1 + p3;

    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Продолжение</h2>
                    <p>
                        А теперь добавим возможность прибавлять к объекту PInt обычные числа типа int:
                    </p>
                    <pre>
                        <code class="cs">
// [Внутри класса]
// Перегрузка оператора +, который принимает в качестве аргументов объект PInt и целое число                 
public static PInt operator +(PInt left, int right)
{
    if (right % 5 != 0)
    {
        return new PInt(left.num + right);
    }
    else
    {
        return new PInt(0);
    }
}

// [В Main]
// Теперь такой код будет работать:
PInt p4 = p1 + 14;
// Но такой - вызовет ошибку:
PInt p5 = 14 + p1;
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Продолжение 2</h2>
                    <p>
                        Чтобы операция работала в обе стороны, нужно добавить аналогичный метод с обратным
                        порядком аргументов:
                    </p>
                    <pre>
                        <code class="cs">
// [Внутри класса]
// Перегрузка PInt + int            
public static PInt operator +(PInt left, int right)
{
    if (right % 5 != 0)
    {
        return new PInt(left.num + right);
    }
    else
    {
        return new PInt(0);
    }
}
// Перегрузка int + PInt  
public static PInt operator +(int left, PInt right)
{
    if (left % 5 != 0)
    {
        return new PInt(left + right.num);
    }
    else
    {
        return new PInt(0);
    }
}

// [В Main]
// Оба варианта рабочие:
PInt p4 = p1 + 14;
PInt p5 = 14 + p1;
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Продолжение 3</h2>
                    <p>
                        Добавим ещё 2 перегрузки для оператора умножения:
                    </p>
                    <pre>
                        <code class="cs">
[Внутри класса]
// Перегруженный оператор умножения *
// Для типов PInt и char
// Возвращает строку
public static string operator *(PInt left, char right)
{
    // Возвращает строковое представление П-числа с добавочным символом, переданным вторым параметром
    return left.ToString().Replace('p', right);
}
// Ещё один перегруженный оператор умножения *
// Для типов int и PInt
// Возвращает int
public static int operator *(int left, PInt right)
{
    // Возвращает обычное число, равно произведению чисел из параметров
    return left * right.num;
}
// Конечно, для них желательно добавить обратные перегрузки (char * PInt и PInt * int)

// [В Main]
// Теперь мы можем делать так:
Console.WriteLine(p4);
Console.WriteLine(p4 * 'П');
// И так:
int num = 4 * p4 + 12;
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Операторы & и |</h2>
                    <p>
                        Сами по себе эти операторы не представляют ничего интересного, интересно то, где
                        они используются.
                    </p>
                </section>
                <section>
                    <h3>Срываем маски</h3>
                    <p>
                        Помните операторы логического объединения И (&&) и ИЛИ (||)? Они не просто так похожи
                        на своих побитовых собратьев.
                    </p>
                    <p>
                        На самом деле, оператор логического И (&&) это просто замаскированная запись:
                    </p>
                    <pre>
                        <code class="cs">
a && b
// эквивалентно
operator false(a) ? a : (a & b);
                        </code>
                    </pre>
                    <p>
                        А оператор логического ИЛИ (||):
                    </p>
                    <pre>
                        <code class="cs">
a || b
// эквивалентно
operator true(a) ? a : (a | b)
                        </code>
                    </pre>
                    <p>
                        В C# это единственное место, в котором вызывается оператор false.
                    </p>
                </section>
                <section>
                    <h2>Операторы && и ||</h2>
                    <p>
                        Это значит, что если вы хотите использовать для объектов вашего класса операторы логического
                        объединения && и ||, вам нужно перегрузить операторы & и |, плюс операторы true и false.
                    </p>
                    <p>
                        Причём методы перегрузки операторов & и | должны обязательно принимать в качестве параметров
                        2 объекта вашего класса, и возвращать объект того же типа.
                    </p>
                </section>
                <section>
                    <h3>Демонстрация</h3>
                    <pre>
                        <code class="cs">
// Класс муравейника
class Anthill
{
    // Свойство Количество муравьёв
    public int AntNumber { get; set; }

    // Конструктор для задания начального количества муравьёв
    public Anthill(int initAntsNum)
    {
        AntNumber = initAntsNum;
    }

    // Перегрузка оператора true
    // Проверка объекта Муравейника на истинность
    public static bool operator true(Anthill ants)
    {
        Console.WriteLine("Operator true");
        // Муравейник истинный, когда количество муравьёв в нём больше 0
        return ants.AntNumber > 0;
    }

    // Перегрузка оператора false
    // Проверка объекта Муравейника на ложность
    public static bool operator false(Anthill ants)
    {
        Console.WriteLine("Operator false");
        // Муравейник ложный, когда количество муравьёв в нём меньше или равно 0
        return ants.AntNumber <= 0;
    }

    // Перегрузка оператора &
    // Чтобы с ней работал оператора &&, метод должен
    // Принимать 2 объекта Anthill и возвращать объект Anthill
    public static Anthill operator &(Anthill ants1, Anthill ants2)
    {
        Console.WriteLine("Operator &");
        // Возвращает муравейник с меньшим количеством муравьёв (из 2 полученных)
        return ants1.AntNumber < ants2.AntNumber ? ants1 : ants2;
    }

    // Перегрузка оператора |
    public static Anthill operator |(Anthill ants1, Anthill ants2)
    {
        Console.WriteLine("Operator |");
        // Возвращает муравейник с Большим количеством муравьёв
        return ants1.AntNumber > ants2.AntNumber ? ants1 : ants2;
    }

}

class Program
{
    static void Main(string[] args)
    {
        // Создаём 2 муравейника
        // Первый - с 13 муравьями
        Anthill a1 = new Anthill(13);
        // Второй - с 0
        Anthill a2 = new Anthill(0);

        // В условии if-а выполняем оператор логического И &&
        // Это будет вызывать конструкцию следующего вида:
        // Anthill.operator false(a1) ? a1 : (a1 & a2)
        // Поскольку эта операция записана в условии if-а, то полный её вид будет таким:
        // Anthill.operator true(Anthill.operator false(a1) ? a1 : (a1 & a2))
        if (a1 && a2)
        {
            Console.WriteLine("a1 && a2 == true\n");
            Console.WriteLine("Both anthill are inhabited");
        }
        Console.WriteLine();

        // По аналогии
        // a1 || a2 эквивалентно Anthill.operator true(a1) ? a1 : (a1 | a2)
        // Целиком: Anthill.operator true(Anthill.operator true(a1) ? a1 : (a1 | a2))
        if (a1 || a2)
        {
            Console.WriteLine("a1 || a2 == true");
            Console.WriteLine("One of the anthills are inhabited");
        }


    }
}
                        </code>
                    </pre>

                </section>
            </section>
            <section>
                <section>
                    <h2>Логические операторы</h2>
                    <p>
                        Все логические операторы - парные, т.е. перегружаются только парами по 2 противоположных
                        оператора.
                    </p>   
                    <ul>
                        <li>&lt; и &gt;</li>
                        <li>&lt;= и &gt;=</li>
                        <li>== и !=</li>
                    </ul>
                    <p>
                        Должны принимать хотя бы 1 объект вашего класса, а возвращать объект булевого типа.
                    </p>
                </section>
                <section>
                    <h2>Больше / меньше</h2>
                    <pre>
                        <code class="cs">
// Класс Комната
class Room
{
    // Свойства Длина, Ширина и Высота стен
    public float Length { get; set; }
    public float Width { get; set; }
    public float WallHeight { get; set; }

    // Конструктор для задания значений свойств
    // У высоты стен значение по умолчанию - 3 метра
    public Room(float length, float width, float height = 3.0f)
    {
        Length = length;
        Width = width;
        WallHeight = height;
    }

    // Перегрузка пары операторов больше-меньше (> и <)
    // Принимают в качестве параметров 2 объекта Room
    public static bool operator >(Room room1, Room room2)
    {
        // Сравнивает через оператор > площади этих комнат и возвращает результат сравнения
        return (room1.Length * room1.Width) > (room2.Length * room2.Width);
    }
    public static bool operator <(Room room1, Room room2)
    {
        // Сравнивает через оператор < площади этих комнат и возвращает результат сравнения
        return (room1.Length * room1.Width) < (room2.Length * room2.Width);
    }

    // Ещё одна перегрузка пары операторов больше-меньше
    // Только теперь для типов параметров Room и float
    public static bool operator >(Room room, float square)
    {
        // Сравнивает площадь переданной комнаты с заданной площадью
        return (room.Length * room.Width) > square;
    }
    public static bool operator <(Room room, float square)
    {
        return (room.Length * room.Width) < square;
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Создаём две комнаты
        Room kitchen = new Room(2.6f, 3.2f);
        Room bedroom = new Room(4.2f, 3.9f);

        // Сравнение: если одна комната больше другой
        // По нашей перегрузке комнаты будут сравниваться по их площадям
        if (bedroom > kitchen)
        {
            Console.WriteLine("The bedroom is larger than kitchen.");
        }

        // Комната сравнивается с числом 6
        // Вызывается другая перегрузка оператора, для Room и float
        // Площадь комнаты kitchen сравнивается с 6
        if (kitchen < 6)
        {
            Console.WriteLine("The kitchen is small");
        }
        // Проверяется, попадает ли площадь комнаты в диапазон (6;16)
        else if (kitchen > 6 && kitchen < 16)
        {
            Console.WriteLine("The kitchen is normal size");
        }
        else
        {
            Console.WriteLine("The kitchen is big");
        }
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Проверка на равенство</h2>
                    <p>
                        При перегрузке операторов == и !=, рекомендуется также переопределять метод
                        Equals(object). Иначе выйдет так, что проверка на равенство разными вариантами
                        будет возвращать разные результаты, а это, согласитесь, выглядит странно.
                    </p>
                    <p>
                        А переопределяя метод Object-а Equals(object) нужно также переопределить 
                        метод GetHashCode (в котором в принципе можно ничего нового не писать).
                    </p>
                    <p>
                        Значит, если вы хотите определить операции сравнения для своего класса, в нём
                        нужно дописать: оператор ==, оператор !=, метод Equals(object) и метод GetHashCode().
                    </p>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="cs">
class Room
{
    public float Length { get; set; }
    public float Width { get; set; }
    public float WallHeight { get; set; }

    public Room(float length, float width, float height = 3.0f)
    {
        Length = length;
        Width = width;
        WallHeight = height;
    }

    // Переопределение метода Equals(object)
    public override bool Equals(object obj)
    {
        // Если переданный объект является комнатой
        if (obj is Room room)
        {
            // Производим сравнение по вычисленной площади
            // Сравнивается комната this и переданная в качестве параметра
            return (this.Length * this.Width) == (room.Length * room.Width);
        }
        else
        {
            // Если второй объект не комната, то они точно не равны - возвращаем false
            return false;
        }
    }

    // Переопределение метода GetHashCode()
    public override int GetHashCode()
    {
        // Просто возвращаем результат вызова родительского метода GetHashCode
        return base.GetHashCode();
    }

    // Перегрузка оператора равенства == для двух комнат
    public static bool operator ==(Room room1, Room room2)
    {
        // Вызывает метод Equals для первой комнта, передавая вторую в качестве параметра
        // Возвращает результат, который вернёт Equals
        return room1.Equals(room2);
    }
    // Перегрузка оператора проверки на неравенство != двух комнат
    public static bool operator !=(Room room1, Room room2)
    {
        // То же самое, что проверка на равенство, только обратное (с помощью оператора Не !)
        return !room1.Equals(room2);
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Создаём 2 комнаты
        Room kitchen = new Room(2.6f, 3.2f);
        Room bedroom = new Room(3.2f, 2.6f);

        Console.Write("(1):  ");
        // Проверяем эти комнаты наравенство
        // Т.е. проверяется равенство их площадей
        if (kitchen == bedroom)
        {
            Console.WriteLine("The kitchen and bedroom are equal in size");
        }
        // Проверяем их на неравенство
        if (kitchen != bedroom)
        {
            Console.WriteLine("The kitchen and bedroom are not equal in size");
        }
        
        Console.Write("(2):  ");
        // Проверка на равенство при помощи метода Equals
        if (kitchen.Equals(bedroom))
        {
            Console.WriteLine("The kitchen and bedroom are equal in size");
        }
        // Проверка на неравенство при помощи Equals
        if (!kitchen.Equals(bedroom))
        {
            Console.WriteLine("The kitchen and bedroom are not equal in size");
        }
    }
}
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <h2>Преобразования типов</h2>
                <p>
                    Вспомним про стандартный механизм преобразования типов:
                </p>
                <p>
                    Преобразования бывают <span class="purple">явными</span> и <span class="purple">неявными</span>.
                </p>
                <p>
                    Для <span class="purple">явного</span> преобразования необходимо перед 
                    переменной написать в круглых скобках желаемый тип:
                </p>
                <pre>
                    <code class="cs">
int a = 2;
// явное преобразование int в char
char c = (char)a;
                    </code>
                </pre>
                <p>
                    Для <span class="purple">неявного</span> преобразования ничего 
                    указывать не нужно, оно происходит само на основании типов:
                </p>
                <pre>
                    <code class="cs">
int a = 2;
// неявное преобразование int в double
double d = a;
                    </code>
                </pre>
            </section>
            <section>
                <section>
                    <h1>Операторы преобразования типов</h1>
                    <p>
                        Так вот, все подобные преобразования выполняются с помощью вызова
                        специальных <span class="purple">операторов преобразования типов</span>.
                    </p>
                    <p>
                        И эти операторы бывают двух видов:
                    </p>
                    <ul>
                        <li><span class="blue">explicit</span> - для явного преобразования</li>
                        <li><span class="blue">implicit</span> - для неявного преобразования</li>
                    </ul>
                </section>
                <section>
                    <h2>Синтаксис</h2>
                    <p>
                        Методы перегрузки операторов преобразования описываются следующим образом:
                    </p>
                    <pre>
                        <code class="cs">
public static [explicit/implicit] operator ToType(fromType param)
{
    // ...
}
                        </code>
                    </pre>
                    <p>
                        1. Перед словом <span class="blue">operator</span> идёт ключевое слово 
                        <span class="blue">explicit</span> или <span class="blue">implicit</span>,
                        в зависимости от того, явное или неявное преобразование мы хотим разрешить.
                    </p>
                </section>
                <section>
                    <h2>Синтаксис 2</h2>
                    <pre>
                        <code class="cs">
public static [explicit/implicit] operator ToType(fromType param)
{
    // ...
}
                        </code>
                    </pre>
                    <p>
                        2. Параметр - объект, который будет преобразовываться. Тип возвращаемого значения -
                        тип, к которому объект из параметра будет преобразован.
                    </p>
                    <p>
                        3. Тип возвращаемого значения описывается здесь не на своём привычном месте: он должен
                        записываться после слова <span class="blue">operator</span>, а не перед, как в обычных методах.
                    </p>
                    <p>
                        4. Один из типов (принимаемый/возвращаемый) должен быть типом, в котором этот оператор описывается.
                    </p>
                    <p>
                        Т.е. можно описывать как операторы преобразования из какого-то типа в ваш, так и наоборот -
                        из вашего типа в какой-либо.
                    </p>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="cs">
// Класс для примера
class SampleClass
{
    // Целочисленное свойство для примера
    public int SampleProperty { get; set; }

    // Перегрузка оператора явного преобразования типа SampleClass к типу int
    public static explicit operator int(SampleClass sc)
    {
        // Возвращает значение из целочисленного свойства SampleProperty объекта sc
        return sc.SampleProperty;
    }
}

class MainClass
{
    static void Main(string[] args)
    {
        // Создаётся объект класса SampleClass
        var obj = new SampleClass();
        obj.SampleProperty = 33;
        // Явное преобразования этого объекта к типу int
        int a = (int)obj;
        // a == 33
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Оператор неявного преобразования</h2>
                    <pre>
                        <code class="cs">
class Person
{
    // Поле и свойство Имя
    private string name;
    public string Name
    {
        get
        {
            // Если значение - пустая строка, возвращаем строку "Неизвестно"
            return name == "" ? "Unknown" : name;
        }
        set
        {
            name = value;
        }
    }
    // Поле и свойство Фамилия
    private string surname;
    public string Surname
    {
        get
        {
            // Если фамилия не задана - возвращаем строку "Неизвестно"
            return surname == "" ? "Unknown" : surname;
        }
        set
        {
            surname = value;
        }
    }
    // Поле и свойство Возраст
    // Обратите внимание, что типа string 
    // Это нужно для того, чтобы возвращать строку "Неизвестно", если возраст не задан
    private string age;
    public string Age
    {
        get
        {
            // Если возраст меньше нуля, возвращаем строку "Неизвестно"
            // *Чтобы сравнить возраст с нулем (число), нужно преобразовать строку к числу
            return int.Parse(age) < 0 ? "Unknown" : age;
        }
        set
        {
            // Проверка, находится ли в строке value числовое значение
            // Через попытку преобразования value к числу
            if (int.TryParse(value, out int a))
            {
                // Если преобразовать получилось - значит эта строка представляет собой числовое значение
                // Всё нормально, и можно строку записать в age
                age = value;
            }
        }
    }

    // Конструктор по умолчанию
    public Person()
    {
        Name = "";
        Surname = "";
        // Задаёт возраст равным -1, чтобы выдавалась строка "Неизвестно"
        Age = "-1";
    }

    // Перегрузка оператора явного преобразования типа string в тип Person
    public static explicit operator Person(string str)
    {
        // Создаём новый объект, который в итоге будем возвращать
        Person ret = new Person();
        // Разбиваем входную строку на подстроки с пробелом в качестве разделителя
        string[] strs = str.Split(' ');
        // Если количество получившихся подстрок больше 2 (как минимум 3)
        // Иначе условие читается, как "Если есть строка под индексом 2"
        if (strs.Length > 2)
        {
            // Записываем строку под индексом 2 в свойство Age возвращаемого объекта ret
            ret.Age = strs[2];
        }
        // Если есть строка под индексом 1
        if (strs.Length > 1)
        {
            // Записываем эту строку в свойство Surname
            ret.Surname = strs[1];
        }
        // Если есть строка под индексом 0
        if (strs.Length > 0)
        {
            // Записываем её в свойство Name
            ret.Name = strs[0];
        }
        // Возвращаем созданный объект
        return ret;
    }

    // Оператор явного преобразования типа Person к типу int
    public static explicit operator int(Person p)
    {
        // Возвращаем преобразованное к числу значение возраста персоны p
        return int.Parse(p.age);
    }

    // Методы для быстрого вывода на консоль информации о персоне
    public void Show()
    {
        Console.WriteLine("Person {0} {1}, age: {2}", Name, Surname, Age);
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Явно преобразуем строку к типу Person и записываем в pers1
        // Здесь вызовется метод оператора explicit operator Person(string str)
        // Куда строка "John Smith" передастся в качестве аргумента str
        Person pers1 = (Person)"John Smith";
        // То же самое
        Person pers2 = (Person)"Dumbo";
        // То же самое
        Person pers3 = (Person)"Scott Fizgerald 44";
        // Теперь можно посмотреть, что у нас получилось
        pers1.Show();
        pers2.Show();
        pers3.Show();

        // Явное преобразование объекта Person к типу int
        int pers3age = (int)pers3;
        // Должно вывести возраст третьей персоны
        Console.WriteLine(pers3age);
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Неявное преобразование</h2>
                    <p>
                        Заменив слово <span class="blue">explicit</span> на <span class="blue">implicit</span>
                        в предыдущем примере можно посмотреть на неявное преобразование. Тогда код использования
                        будет выглядеть так:
                    </p>
                    <pre>
                        <code class="cs">
static void Main(string[] args)
{
    // Теперь не нужно указывать тип Person в скобках
    // Преобразование выполняется неявно
    Person pers1 = "John Smith";
    Person pers2 = "Dumbo";
    Person pers3 = "Scott Fizgerald 44";
    pers1.Show();
    pers2.Show();
    pers3.Show();

    // Как и здесь
    int pers3age = pers3;
    Console.WriteLine(pers3age);
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Применение</h3>
                    <p>
                        Может возникнуть вопрос, зачем тогда вообще явные преобразования, если
                        неявные гораздо удобнее?
                    </p>
                    <p>
                        Но нет, всё совершенно наоборот: рекомендуется использовать только явные
                        преобразования, а неявные использовать лишь в крайней необходимости.
                    </p>
                    <p>
                        Почему?
                    </p>
                    <p>
                        Потому что неявные преобразования происходят <u>незаметно</u> для программиста.
                        Их труднее найти в коде, да о них просто можно и не знать. С неявным преобразованием
                        нельзя понять - было ли оно использовано умышленно, или программист вообще не 
                        подозревал, что там есть преобразование.
                    </p>
                </section>
                <section>
                    <h3>Финальный пример с П-числами</h3>
                    <pre>
                        <code class="cs">
// Класс П-числа                            
class PInt
{
    // Приватное поле для хранения внутреннего значения
    private int num;

    // Конструктор на основании целого числа
    public PInt(int init)
    {
        num = init;
        if (num % 5 == 0)
        {
            ++num;
        }
    }

    // Конструктор копирования
    public PInt(PInt p)
    {
        num = p.num;
    }
    
    // Оператор сложения двух П-чисел
    public static PInt operator +(PInt left, PInt right)
    {
        int numberOfFives = right.num / 5;
        PInt retP = new PInt(left.num);
        retP.num += right.num - numberOfFives;
        if (retP.num % 5 == 0)
        {
            ++retP.num;
        }
        return retP;
    }
    
    // Оператор вычитания двух П-чисел
    public static PInt operator -(PInt left, PInt right)
    {
        int numberOfFives = right.num / 5;
        PInt retP = new PInt(left.num);
        retP.num -= right.num - numberOfFives;
        if (retP.num % 5 == 0)
        {
            --retP.num;
        }
        return retP;
    }

    // Оператор умножения двух П-чисел
    public static PInt operator *(PInt left, PInt right)
    {
        PInt retP = new PInt(left.num * right.num);
        return retP;
    }

    // Оператор деления двух П-чисел
    public static PInt operator /(PInt left, PInt right)
    {
        PInt retP = new PInt(((left.num / right.num) + (right.num / left.num)) / 2);
        return retP;
    }

    // Оператор неявного преобразования int к PInt
    public static implicit operator PInt(int arg)
    {
        // Создаёт и возвращает объект нового П-числа, на основе переданного параметра
        return new PInt(arg);
    }

    // Оператор явного преобразования PInt к int
    public static explicit operator int(PInt arg)
    {
        // Просто возвращает значение поля num
        return arg.num;
    }

    // Переопределение метода ToString
    public override string ToString()
    {
        return num.ToString() + "p";
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Благодаря перегрузке оператора преобразования int к PInt
        // Можно создавать числа PInt так просто:
        PInt p1 = 245;
        PInt p2 = 141;
        PInt p3 = -300;

        // Благодаря перегрузкам математических операторов
        // Можно описывать операции вот так:
        PInt p4 = p1 + p2;
        PInt p5 = p1 - p2;
        PInt p2 *= p5;
        PInt p7 = p1 / p6;

        // Явное преобразование к int-у
        int num = (int)p7;

    }
}
                        </code>
                    </pre>
                </section>
            </section>
		</div>
	</div>
	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
    <aside id="presentable-icon-close">
        <a title="К списку материалов" href="../../index.html#/1">
            <i class="fa fa-times fa-2x"></i>
        </a>
    </aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>