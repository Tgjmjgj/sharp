<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Object-oriented programming</title>
	<meta name="description" content="programming paradigm OOP in C#, concept of classes and objects, attributes and methods">
	<meta name="keywords" content="c#, oop, class, object, interface">
	<meta name="author" content="Edward & Albert">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0 ">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? "../../css/print/pdf.css" : "../../css/print/paper.css";
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Объектно-ориентированное программирование</h1>
                    <h3>Полиморфизм</h3>
					<div>
						<p style="display: inline-block;">
							Edward &amp; Albert / 
						</p>
						<a href="https://github.com/tgjmjgj" class="icon-button github">
							<i class="fa fa-github"></i><span></span>
						</a>
						<a href="https://facebook.com/paradox7master" class="icon-button facebook">
							<i class="fa fa-facebook"></i><span></span>
						</a>
					</div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<section>
				<section>
					<h1>Полиморфизм</h1>
					<img src="img/polymorphism.jpg" />
				</section>
				<section>
					<h2>Определение полиморфизма</h2>
					<blockquote>
						<span class="purple">Полиморфизмом</span> называется способность одних типов выступать
						в форме других типов. Или же способность функции обрабатывать данные разных типов.
					</blockquote>
				</section>
				<section>
					<h2>База</h2>
					<p>
						Как один тип может выступать в форме другого типа?
					</p>
					<p>
						Попробуем взглянуть на наследование с такой стороны:
					</p>
					<p>
						Наследование - это отношение "является". Любой производный класс
						"является" сущностью, которую представляет его базовый класс.
					</p>
					<p>
						Пусть у нас есть класс <span class="turquoise">Fruit</span>. И класс 
						<span class="turquoise">Banana</span>, производный от него. А ещё класс
						<span class="turquoise">Apple</span>, тоже потомок <span class="turquoise">Fruit</span>.
					</p>
					<p>
						В таком случае, <span class="turquoise">Banana</span> "является"
						<span class="turquoise">Fruit</span> и <span class="turquoise">Apple</span>
						"является" <span class="turquoise">Fruit</span>.
					</p>
				</section>
				<section>
					<h2>Полиморфизм в коде</h2>
					<p>
						Это свойство классов проявляется в коде в виде возможности представить объект 
						какого-то класса в виде объекта базового для него класса. 
					</p>
					<pre>
						<code class="cs">
// Базовый класс Фрукт
class Fruit
{
	// Свойство Название
	public string Name { get; set; }
}

// Производный от Фрукта класс Банан
class Banana : Fruit
{
	// Свойство Длина
	public int Length { get; set; }
}

// Производный от Фрукта класс Яблоко
class Apple : Fruit
{
	// Свойство Цвет
	public string Color { get; set; }
}

class Program
{
	static void Main(string[] args)
	{
		// Создаём экземпляр класса Banana
		Banana ban = new Banana();
		// Присваиваем объект типа Banana ссылке на тип Fruit
		Fruit fruit = ban;

		// Создаём экземпляр класса Apple
		Apple ap = new Apple();
		// Присваиваем объект типа Aplle ссылке на тип Fruit
		Fruit fr2 = ap;

		// Создаём ещё один объект типа Apple и помещаем его в тип Fruit
		Fruit fr3 = new Apple();
	}
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Виды полиморфизма</h2>
					<p>
						Полиморфизм бывает 2 видов:
					</p>
					<ul>
						<li>Параметрический (истинный) полиморфизм</li>
						<li>Ad hoc полиморфизм</li>
					</ul>
					<p>
						Ad hoc полиморфизм является не совсем настоящим полиморфизмом. Он наблюдается тогда,
						когда мы вручную прописываем различные варианты поведения для различных типов.
					</p>
				</section>
				<section>
					<h2>Ad hoc полиморфизм</h2>
					<p>
						Простейшим случаем Ad hoc полиморфизма можно считать перегрузку функций:
						когда мы для различных типов параметров прописываем различные варианты методов.
					</p>
					<pre>
						<code class="cs">
// Класс Шеф-повара
class Chef
{
	// Метод Приготовить что-нибудь из банана
	public string CookSmth(Banana b)
	{
		return "Banana cake";
	}

	// Метод Приготовить что-нибудь из яблока
	public string CookSmth(Apple a)
	{
		return "Charlotte";
	}

	// Метод Приготовить что-нибудь из киви
	public string CookSmth(Kiwi k)
	{
		return "Smoothie";
	}
	
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Ad hoc полиморфизм</h2>
					<p>
						Ещё один вариант Ad hoc полиморфизма - когда для всех типов у нас используется
						один общий метод, но всё равно проверяется исходный тип и для каждого типа
						выполняются отдельные действия.
					</p>
					<pre>
						<code class="cs">
class Chef
{
	// Метод Приготовить что-нибудь из фрукта
	public string CookSmth(Fruit fruit)
	{
		string meal = "nothing";
		// Если тип фрукта  - банан
		if (fruit is Banana)
		{
			meal = "Banana cake";
		}
		// Если тип фрукта  - яблоко
		else if (fruit is Apple)
		{
			meal = "Charlotte";
		}
		// Если тип фрукта  - киви
		else if (fruit is Kiwi)
		{
			meal = "Smoothie";
		}
		return meal;
	}
	
}

class Program
{
	static void Main(string[] args)
	{
		// Создаём шефа
		Chef mrChef = new Chef();

		// По одному экземпляру каждого класса
		Fruit fruit1 = new Fruit();
		Banana fruit2 = new Banana();
		Apple fruit3 = new Apple();
		Kiwi fruit4 = new Kiwi();

		// И смотрим варианты вызова метода CookSmth,
		// передавая в него объекты разных типов
		string meal = mrChef.CookSmth(fruit1);
		Console.WriteLine("First meal: " + meal);

		meal = mrChef.CookSmth(fruit2);
		Console.WriteLine("Next meal: " + meal);

		meal = mrChef.CookSmth(fruit3);
		Console.WriteLine("Next meal: " + meal);

		meal = mrChef.CookSmth(fruit4);
		Console.WriteLine("And final meal: " + meal);
	}
}
						</code>
				</section>
				<section>
					<h2>Коллекции и полиморфизм</h2>
					<p>
						Благодаря полиморфизму мы можем не только создавать методы,
						которые будут работать с разными типами, как с одним, но и 
						работать с коллекциями из объектов разных классов.
					</p>
					<p>
						Зная, что объекты классов <span class="turquoise">Banana</span>,
						<span class="turquoise">Apple</span> и <span class="turquoise">Kiwi</span>
						могут быть представлены как объекты класса <span class="turquoise">Fruit</span>,
						мы спокойно можем создать массив фруктов, и поместить в него все наши объекты.
					</p>
					<p>
						Упростим код из предыдущего примера с помощью этой техники.
					</p>
				</section>
				<section>
					<h3>Фрукты</h3>
					<pre>
						<code class="cs">
static void Main(string[] args)
{
	// Шефа не трогам
	Chef mrChef = new Chef();

	// Объявляем массив фруктов и инициализируем его списком объектов разных классов
	Fruit[] fruits = { new Fruit(), new Banana(), new Apple(), new Kiwi() };

	// Циклом перебираем фрукты в массиве
	foreach (Fruit fruit in fruits)
	{
		string meal = mrChef.CookSmth(fruit);
		Console.WriteLine("Next meal: " + meal);
	}
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Оператор is</h2>
					<p>
						Как вы уже поняли, оператор <span class="blue">is</span> используется для проверки,
						"является" ли объект указанным типом, т.е. находится ли этот тип в иерархии наследования
						проверяемого объекта.
					</p>
					<p>
						Главная особенность именно в том, что он проверяет не только тот тип, которым создавался
						объект, а все типы в его иерархии наследования (а также реализуемые интерфейсы). 
					</p>
					<p>
						Это значит, что, например, для объекта класса <span class="turquoise">Apple</span> 
						положительными были бы проверки, что он является <span class="turquoise">Apple</span>,
						<span class="turquoise">Fruit</span> и <span class="turquoise">Object</span>.
					</p>
					<p>
						Синтаксис вы уже видели:
					</p>
					<pre>
						<code class="cs">
объект is тип
						</code>
					</pre>
				</section>
				<section>
					<h2>Класс Type</h2>
					<p>
						Существует и другой способ, как узнать какой конкретно тип у объекта, через
						класс <span class="turquoise">Type</span>.
					</p>
					<p>
						<span class="turquoise">Type</span> - специальный класс, представляющий собой
						информацию о каком-либо типе. Для любого типа (класса) можно получить соответствующий
						ему объект класса <span class="turquoise">Type</span>.
					</p>
					<p>
						И именно для этого в классе <span class="turquoise">Object</span> есть метод
						GetType(). А раз он есть в классе <span class="turquoise">Object</span>, он есть
						в любом классе .NET.
					</p>
					<p>
						Этот метод возвращает объект типа для своего объекта.
					</p>
					<p>
						Но с чем его сравнивать?
					</p>
				</section>
				<section>
					<h2>Оператор typeof</h2>
					<p>
						Оператор <span class="blue">typeof</span> возвращает объект класса
						<span class="turquoise">Type</span> для заданного <u>типа</u>.
					</p>
					<p>
						Синтаксис применения у него следующий:
					</p>
					<pre>
						<code class="cs">
typeof(тип)
						</code>
					</pre>
					<p>
						Итак, GetType позволяет получить объект <span class="turquoise">Type</span>
						для объекта, <span class="blue">typeof</span> позволяет получить объект
						<span class="turquoise">Type</span> для типа.
					</p>
					<p>
						Скомбинировав их, мы можем записать проверку на однозначное
						соответствие объекта какому-либо типу:
					</p>
					<pre>
						<code class="cs">
объект.GetType() == typeof(тип)
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="cs">
Banana banan = new Banana();

Console.WriteLine("Operator is:");
Console.WriteLine("  banan is Banana: {0}", banan is Banana);	// true
Console.WriteLine("  banan is Kiwi: {0}", banan is Kiwi);		// false
Console.WriteLine("  banan is Fruit: {0}", banan is Fruit);		// true
Console.WriteLine("  banan is Object: {0}", banan is Object);	// true


Console.WriteLine("Class Type:");
Console.WriteLine("  banan.GetType() == typeof(Banana): {0}", banan.GetType() == typeof(Banana));	// true
Console.WriteLine("  banan.GetType() == typeof(Kiwi): {0}", banan.GetType() == typeof(Kiwi));		// false
Console.WriteLine("  banan.GetType() == typeof(Fruit): {0}", banan.GetType() == typeof(Fruit));		// false
Console.WriteLine("  banan.GetType() == typeof(Object): {0}", banan.GetType() == typeof(Object));	// false
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Обратное преобразование</h2>
					<p>
						Иногда бывает нужно восстановить исходный тип объекта.
					</p>
					<p>
						Например, передав объект класса <span class="turquoise">Banana</span> в метод
						в виде <span class="turquoise">Fruit</span>, восстановить из этого
						<span class="turquoise">Fruit</span> исходный тип <span class="turquoise">Banana</span>.
					</p>
					<p>
						Если попробовать выполнить преобразование через обычный синтаксис приведения типов,
						в случае, если попадётся не совместимый тип, программа выбросит исключение.
					</p>
					<pre>
						<code class="cs">
public void SomeMethod(Fruit fruit)
{
	// В случае, если сюда передать любой фрукт, кроме банана
	// Произойдет исключение - преобразование типов невозможно
	Banana ban = (Banana)fruit;
	Console.WriteLine("Banana length is: " + ban.Length);
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Оператор as</h2>
					<p>
						Конечно можно сначала написать условие, проверяющее тип, и только в случае
						выполнения этого условия проводить преобразование... Но есть и другой способ.
					</p>
					<p>
						Оператор <span class="blue">as</span> выполняет преобразование объекта в тип,
						находящийся в его иерархии наследования, а если указанный тип не связан с объектом
						- возвращает нулевую ссылку <span class="blue">null</span>. Исключений здесь не происходит.
					</p>
					<p>
						Синтаксис у него такой:
					</p>
					<pre>
						<code class="cs">
ожидаемый_тип новое_имя = объект as ожидаемый_тип;
						</code>
					</pre>
					<p>
						Оператор <span class="blue">as</span> подходит только для преобразования типов,
						связанных наследственными узами.
					</p>
				</section>
				<section>
					<h2>Использование</h2>
					<pre>
						<code class="cs">
// Теперь нужно только проверить, что преобразование удалось выполнить
Banana ban = fruit as Banana;
if (ban != null)
{
	Console.WriteLine("Banana length is: " + ban.Length);
}
						</code>
					</pre>
					<p>
						Вообще, с 7 версии C# оператор <span class="blue">as</span> стал
						немного бесполезным, потому что его функциональность добавили к 
						новой форме оператора <span class="blue">is</span>:
					</p>
					<pre>
						<code class="cs">
// Теперь преобразовывать можно прямо в операторе is
if (fruit is Banana ban)
{
	// Если проверка is пройдёт, то здесь будет доступен преобразованный объект ban
	Console.WriteLine("Banana length is: " + ban.Length);
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Вспомнили про Object..</h2>
					<p>
						Если <span class="turquoise">Object</span> является прародителем всего и вся,
						значит объект любого класса может быть представлен типом <span class="blue">object</span>?
					</p>
					<p>
						В общем-то, да.
					</p>
					<p>
						Можно написать метод, принимающий параметр типа <span class="blue">object</span>,
						и тогда в этот метод можно будет передать объект абсолютно любого класса.
					</p>
					<p>
						Правда, это редко бывает нужно.
					</p>
				</section>
				<section>
					<h2>Боксинг и анбоксинг</h2>
					<p>
						Но у такого представления в виде типа <span class="blue">object</span> есть и 
						свои преимущества. А именно, если говорить о хранении в виде <span class="blue">object</span>
						структур (стандартных типов данных: <span class="blue">int</span>, <span class="blue">float</span>,
						<span class="blue">bool</span> и т.д.)
					</p>
					<p>
						Структуры являются <span class="purple">типами значений</span>, а это значит, что в методы
						передаются копии их значений.
					</p>
					<p>
						А <span class="turquoise">Object</span> является классом, т.е. ссылочным типом, и объекты
						типа <span class="blue">object</span> передаются в методы по ссылке.
					</p>
					<p>
						У этого даже есть специальные названия:
					</p>
					<p>
						Представление типа значения в виде <span class="blue">object</span> - 
						<span class="purple">боксинг</span>.
					</p>
					<p>
						Возвращение типа значения из типа <span class="blue">object</span>
						в объект исходного типа - <span class="purple">анбоксинг</span>.
					</p>
				</section>
			</section>
			<section>
				<h2>Виды полиморфизма</h2>
				<p>
					Ещё одна классификация видов полиморфизма.
				</p>
				<p>
					По типу применяемых элементов полиморфизм делится на:
				</p>
				<ul>
					<li>Полиморфизм подтипов</li>
					<li>Полиморфизм интерфейсов</li>
				</ul>
				<p>
					Мы пока рассматриваем полиморфизм подтипов (т.е. на основе наследования).
				</p>
				<p>
					И до этого он у нас был ненастоящим (ad hoc полиморфизм).
				</p>
			</section>
			<section>
				<h2>Истинный (параметрический) полиморфизм</h2>
				<p>
					Что же такое истинный полиморфизм?
				</p>
				<p>
					Полиморфизм считается истинным, когда в методе описан только один
					сценарий поведения для любых входных типов. Но тем не менее, поведение
					меняется в зависимости от типа входящего объекта.
				</p>
				<p>
					И как такого можно достичь?
				</p>
			</section>
			<section>
				<section>
					<h2>Перегрузка методов</h2>
					<p>
						И это ответ: с помощью перегрузки методов.
					</p>
					<p>
						Описав в базовом классе виртуальный метод, функция, работающая с
						этим базовым классом, может вызывать этот виртуальный метод. А он, в свою очередь,
						у каждого производного класса будет переопределён и реализован по-своему.
					</p>
					<p>
						Т.е. вызываться будет один метод, но он будет делать разные вещи, в зависимости
						от того, как он переопределён в этом классе.
					</p>
				</section>
				<section>
					<h2>Пример настоящего полиморфизма</h2>
					<pre>
						<code class="cs">
class Fruit
{
	public string Name { get; set; }

	// Виртуальный метод "Получить блюдо"
	public virtual string GetMealFromThis()
	{
		return "Nothing";
	}
}

class Banana : Fruit
{
	public int Length { get; set; }

	// Этот метод переопределён
	// И для банана возвращает такую строку
	public override string GetMealFromThis()
	{
		return "Banana Cake";
	}
}

class Apple : Fruit
{
	public string Color { get; set; }

	// Для яблока вторую
	public override string GetMealFromThis()
	{
		return "Charlotte";
	}
}

class Kiwi : Fruit
{
	public string Size { get; set; }

	// А для киви третью
	public override string GetMealFromThis()
	{
		return "Smoothie";
	}
}

class Chef
{
	// Метод Приготовления
	public string CookSmth(Fruit fruit)
	{
		// Просто возвращает результат выполнения метода GetMealFromThis
		return fruit.GetMealFromThis();
	}
	
}

class Program
{
	static void Main(string[] args)
	{
		Chef mrChef = new Chef();

		Fruit[] fruits = { new Fruit(), new Banana(), new Apple(), new Kiwi() };

		foreach (Fruit fruit in fruits)
		{
			string meal = mrChef.CookSmth(fruit);
			Console.WriteLine("Next meal: " + meal);

		}
	}
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Переопределение и сокрытие</h2>
					<p>
						Теперь можно и рассказать про различия <span class="purple">переопределения</span> от
						<span class="purple">сокрытия</span>.
					</p>
					<p>
						При переопределении, как вы увидели, в случае представления объекта в форме базового класса,
						при вызове виртуального метода вызывается его переопределённая версия из дочернего класса. 
					</p>
					<p>
						При сокрытии же такого не происходит, и полиморфизм не работает. Для объекта базового класса
						всегда будет выполняться вариант метода, описанный в базовом классе.
					</p>
				</section>
				<section>
					<h3>Демонстрация различий</h3>
					<pre>
						<code class="cs">
class Fruit
{
	public string Name { get; set; }

	public virtual string GetMealFromThis()
	{
		return "Nothing";
	}

	// Добавили новый виртуальный метод
	public virtual string GetSauce()
	{
		return "out sauce";
	}
}

class Banana : Fruit
{
	public int Length { get; set; }

	public override string GetMealFromThis()
	{
		return "Banana Cake";
	}

	// Скрываем оригинал новой версией
	public new string GetSauce()
	{
		return " banana ketchup";
	}
}

class Apple : Fruit
{
	public string Color { get; set; }

	public override string GetMealFromThis()
	{
		return "Charlotte";
	}

	// Скрываем оригинал новой версией
	public new string GetSauce()
	{
		return " apple juice";
	}
}

class Kiwi : Fruit
{
	public string Size { get; set; }

	public override string GetMealFromThis()
	{
		return "Smoothie";
	}

	// Скрываем оригинал новой версией
	public new string GetSauce()
	{
		return " kiwi compote";
	}
}

class Chef
{
	public string CookSmth(Fruit fruit)
	{
		// Формирует результат из вызовов двух методов
		return fruit.GetMealFromThis() + " with" + fruit.GetSauce();
	}
	
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h3>Пример</h3>
				<pre>
					<code class="cs">
// Базовый абстрактный класс Музыкального Инструмента
abstract class MusicalInstrument
{
	// Свойство тип
	public string Type { get; set; }

	// Конструктор по умолчанию
	public MusicalInstrument()
	{
		Type = "Unknown";
	}

	// Конструктор с параметром
	public MusicalInstrument(string type)
	{
		Type = type;
	}

	// Абстрактный метод
	public abstract void Play();
}

// Производный класс Гитары
class Guitar : MusicalInstrument
{
	// Свойство Количество струн
	public int StringCount { get; set; }

	// Конструктор по умолчанию
	public Guitar()
	{
		Type = "Spanish guitar";
		StringCount = 6;
	}

	// Конструктор с параматерами
	public Guitar(string type, int strings) : base(type)
	{
		StringCount = strings;
	}

	// Переопределённый метод Play
	// Играет музыку гитары
	public override void Play()
	{
		Console.WriteLine("Jug-jug-strum-neowwwwwhh");
		Console.WriteLine("Wwwaahhhhhwahwahwahwahhhh");
		Console.WriteLine("Neowwwwwwh... strum");
		Console.WriteLine("Neowh-newh-newh-newh-newh-newwwwhh..");
	}

}

// Производный класс Трубы
class Trumpet : MusicalInstrument
{
	// Конструктор по умолчанию
	public Trumpet()
	{
		Type = "Piccolo trumpet";
	}

	// Конструктор с параметром
	public Trumpet(string type) : base(type) { }

	// Переопределённый метод Play
	// Играет звуки трубы
	public override void Play()
	{
		Console.WriteLine("Thuuuuuu! Thu! Thu!");
		Console.WriteLine("Pah-pa-pah!");
		Console.WriteLine("Thuuuuuu-rhu! Thu! Thu! Rhuuh!");
	}

}

// Производный класс Барабанов
class DrumKit : MusicalInstrument
{
	// Свойство Количество барабанов
	public int Drums { get; set; }

	// Конструктор по умолчанию
	public DrumKit()
	{
		Type = "Four-piece kit";
		Drums = 4;
	}

	// Конструктор с параметрами
	public DrumKit(string type, int drums) : base(type)
	{
		Drums = drums;
	}

	// Переопределённый метод Play
	// Издаёт звуки барабанов
	public override void Play()
	{
		Console.WriteLine("Rub-a-dub dabum tish!");
		Console.WriteLine("Bum! Brrum! Brrrumble!!!!");
		Console.WriteLine("Pump-a-rum-parum Pump-a-rum! Tish! ");
	}
}

// Класс Музыкант
class Musician
{
	// Свойста Имя, Опыт и Музыкальный инструмент
	public string Name { get; private set; }
	public int Experience { get; set; }
	public MusicalInstrument Instrument { get; set; }

	// Конструктор с параметрами
	public Musician(string name, int exp, MusicalInstrument instrum)
	{
		this.Name = name;
		this.Experience = exp;
		this.Instrument = instrum;
	}

	// Метод "Исполнять музыку"
	public void PerformMusic()
	{
		// Вызывает метод Play для его текущего инструмента
		this.Instrument.Play();
	}

}

class Program
{
	static void Main(string[] args)
	{
		// Создаём инструменты
		Guitar guitar = new Guitar();
		Trumpet trumpet = new Trumpet("Baroque trumpet");
		DrumKit drumKit = new DrumKit("Electronic drums", 8);

		// Создаём музыканта
		Musician musician = new Musician("Robert", 12, guitar);
		ConsoleKeyInfo key;
		do
		{
			Console.WriteLine("Choose an instrument or start playing music!");
			Console.WriteLine("  1 - Select Guitar");
			Console.WriteLine("  2 - Select Trumpet");
			Console.WriteLine("  3 - Select DrumKit");
			Console.WriteLine("  Other - Start Playing");
			Console.WriteLine("  ESC - Exit");
			key = Console.ReadKey(true);
			// Выбор инструмента
			switch (key.Key)
			{
				// В зависимости от кейса даём музыканту разные инструменты
				case ConsoleKey.D1:
					musician.Instrument = guitar;
					break;
				case ConsoleKey.D2:
					musician.Instrument = trumpet;
					break;
				case ConsoleKey.D3:
					musician.Instrument = drumKit;
					break;
				case ConsoleKey.Escape:
					break;
				default:
					Console.WriteLine("To stop playing music press any key.");
					do
					{
						// Просто вызываем метод PerformMusic
						musician.PerformMusic();
						System.Threading.Thread.Sleep(1000);
					}
					while (!Console.KeyAvailable);
					// Пока не будет нажата любая клавиша
					Console.ReadKey(true);
					break;
			}
			Console.Clear();
		}
		while (key.Key != ConsoleKey.Escape);
		// Заканчиваем программу по нажатию ESC
	}
}
					</code>
				</pre>
			</section>
			<section>
				<h3>Пример 2</h3>
				<pre>
					<code class="cs">
// Класс Пища
abstract class Feed
{
	// Свойства
	public string Kind { get; set; }
	public string Composition { get; set; }
	public int KKal { get; set; }
}

// Класс Трава
class Grass : Feed
{
	public string Freshness { get; set; }
	public string Dryness { get; set; }
}

// Класс Орех
class Nut : Feed
{
	public int Strength { get; set; }
}

// Класс Листья
class Leaves : Feed
{
	public int Number { get; set; }
}

abstract class Animal
{
	public abstract string Specie { get; protected set; }
	public abstract string Name { get; set; }

	protected Random gen;

	protected static string Voice { get; set; }

	public int Age { get; set; }

	public Animal()
	{
		gen = new Random();
	}

	// Абстрактный метод Breeding
	public abstract bool Breeding();

	// Абстрактный метод GetCub возвращает объект класса Animal
	public abstract Animal GetCub();

	// Виртуальный метод Eat принимает объект класса Feed
	public virtual void Eat(Feed feed)
	{
		Console.WriteLine($"{Specie} {Name} eat {feed.Kind}");
	}

	public string MadeSound()
	{
		Console.WriteLine($"{Voice} - {Voice}!");
		return Voice;
	}


}

class Turtle : Animal
{
	// Закрытое поле - булевый флаг, используется в методах для контроля соответствия размножения-детёнышей
	private bool canGetChild;

	private string specie;
	public override string Specie
	{
		get
		{
			return specie;
		}
		protected set
		{
			if (string.Compare(value, "Green Turtle", true) == 0 ||
				string.Compare(value, "Flatback", true) == 0 ||
				string.Compare(value, "Loggerhead", true) == 0)
			{
				specie = value;
			}
		}
	}

	public override string Name { get; set; }

	static Turtle()
	{
		Voice = "....";
	}

	// Конструктор по умолчанию
	public Turtle()
	{
		canGetChild = false;
		Specie = "turtle";
	}

	// Переопределённый метод Breeding
	public override bool Breeding()
	{
		int randInt = gen.Next(3);
		if (randInt == 0)
		{
			// С шансом 1:3 черепаха откладывает яйцо
			Console.WriteLine("Turtle {0} laid egg on the beach!", Name);
			System.Threading.Thread.Sleep(500);
			Console.WriteLine("...................");
			System.Threading.Thread.Sleep(2000);
			// И переключаем флаг на true
			canGetChild = true;
			Console.WriteLine("Now you can get turtles child!");
			return true;
		}
		else
		{
			// 2:3 что яйца отложить не выйдет
			Console.WriteLine("Turtle {0} failed to lay eggs...", Name);
			return true;
		}
	}

	// Переопределённый метод GetCub
	public override Animal GetCub()
	{
		// Если было отложено яйцо
		if (canGetChild)
		{
			canGetChild = false;
			int rnd = gen.Next(4);
			if (rnd != 3)
			{
				// Выдаём черепашку с шансом 3:4
				Console.WriteLine("New turtle hatches from egg!");
				return new Turtle();
			}
			else
			{
				// 1:4 что черепашки не будет
				Console.WriteLine("Oh no! Sand snake catch and kill little turtle!");
				return null;
			}
		}
		else
		{
			// Иначе выдаём пустую ссылку null
			Console.WriteLine("To have a cub, turtle must first breed!");
			return null;
		}
	}

	// Переопределённый метод Eat
	public override void Eat(Feed feed)
	{
		// Проверям, что тип пищи - трава
		if (feed is Grass)
		{
			// И тогда вызываем метод Eat базового класса
			base.Eat(feed);
		}
		else
		{
			// Если не трава, то черепаха не может съесть это
			Console.WriteLine("Turtle can't eat this!");
		}
	}

}

// Класс Улитки
class Snail : Animal
{
	// Булевый флаг для индикации, отложила ли улитка яйца
	private int breedAttemptLeft;
	// Количество отложенных яиц
	private int eggsCount;
	
	public override string Specie { get; protected set; }

	public override string Name { get; set; }

	static Snail()
	{
		Voice = "................What do you expect to hear from the snail?";
	}

	// Конструктор по умолчанию
	public Snail()
	{
		// У улитки есть 5 попытко отложить яйца
		breedAttemptLeft = 5;
		// Изначально у неё нет яиц
		eggsCount = 0;
		Specie = "snail";
	}

	// Переопределённый метод Breeding
	public override bool Breeding()
	{
		if (breedAttemptLeft != 0)
		{
			// Отнимаем попытку
			breedAttemptLeft--;
			var randomGenerator = new Random();
			int randInt = randomGenerator.Next(6);
			if (randInt == 0)
			{
				// С вероятностью 1:6 она откладывает 0-50 яиц
				eggsCount = randomGenerator.Next(100);
				Console.WriteLine("Snail {0} buried {1} eggs in the ground!", Name, eggsCount);
				System.Threading.Thread.Sleep(500);
				Console.WriteLine("...................");
				System.Threading.Thread.Sleep(2000);
				Console.WriteLine("Now eggs can hatch!");
				return true;
			}
			else
			{
				Console.WriteLine("Snail {0} failed to lay eggs...", Name);
				return false;
			}
		}
		else
		{
			Console.WriteLine("Snail {0} can no longer breed!", Name);
			return false;
		}
	}

	// Переопределённый метод GetCub
	public override Animal GetCub()
	{
		// Если есть яйца
		if (eggsCount != 0)
		{
			// Можно получать маленьких улиточек
			eggsCount--;
			Console.WriteLine("{0} eggs left...", eggsCount);
			Random gen = new Random();
			int randInt = gen.Next(5);
			// Если повезёт, т.к. не из каждого яйца они вылупляются
			if (randInt == 0)
			{
				Console.WriteLine("Ctchhh! There is new Snail!");
				return new Snail();
			}
			else
			{
				Console.WriteLine("Ctchhh! But.. Egg is empty...");
				return null;
			}
		}
		else
		{
			Console.WriteLine("No eggs - no cubs. Sorry.");
			return null;
		}
	}

	// Переопределённый метод Eat
	public override void Eat(Feed feed)
	{
		// Если пища это Листья
		if (feed is Leaves)
		{
			// То можно есть
			base.Eat(feed);
		}
		else
		{
			// Иначе не стоит
			Console.WriteLine("You're kidding! Snail can't eat this!");
		}
	}
}
// Класс Зверинца
class Menagerie
{
	// Список животных
	public List&lt;Animal&gt; Animals { get; set; }

	// Индексатор
	public Animal this[int index]
	{
		get { return Animals[index]; }
		set { Animals[index] = value; }
	}

	// Конструктор для инициализации списка
	public Menagerie()
	{
		Animals = new List&lt;Animal&gt;();
	}

	// Метод для добавления нового животного в зверинец
	public void AddNewAnimal(Animal a)
	{
		Animals.Add(a);
	}

	// Метод для кормления животного
	public void FeedAnimal(Animal a, Feed f, int quantity = 1)
	{
		// Ищем это животное в нашем зверинце
		int index = Animals.IndexOf(a);
		// Если оно присутствует
		if (index != -1)
		{
			// Кормим quantity раз
			for (int i = 0; i < quantity; ++i)
			{
				Animals[index].Eat(f);
			}
		}
	}

	// Метод для размножения случайного животного в зверинце
	public Animal RandomBreed()
	{
		Random random = new Random();
		int i = random.Next(Animals.Count);
		// Выбираем случайное животное
		Animal animal = Animals[i];
		// Вызываем метод размножения
		animal.Breeding();
		// Возвращаем животное, которое размножалось
		return animal;
	}
}

class Program
{
	static void Main(string[] args)
	{
		// Черепаха Боб
		Turtle t = new Turtle();
		t.Name = "Bob";

		// Улитка Мэгги
		Snail s = new Snail();
		s.Name = "Maggy";

		// Улитка Маркус
		Snail ss = new Snail();
		ss.Name = "Markus";

		// Создаём зверинец
		Menagerie mg = new Menagerie();
		// Забрасываем в него нашу живность
		mg.AddNewAnimal(t);
		mg.AddNewAnimal(s);
		mg.AddNewAnimal(ss);

		// Создаём листья
		Leaves leaves = new Leaves();
		leaves.Kind = "Palm leaves";
		// Кормим Маркуса 5 листьями
		mg.FeedAnimal(ss, leaves, 5);
		// Кормим боба листиком
		mg.FeedAnimal(t, leaves);

		string[] names = { "Austin", "Brock", "Caleb", "Dominic", "Emmett", "Finn", "Guy", "Hogan", "Irving",
		"Jace", "Kingston", "Lambert", "Mickey", "Nolan", "Oliver", "Parker", "Quinn", "Ramsey", "Samson",
		"Thomas", "Upton", "Vinny", "Wade", "Xander", "York", "Zane" };

		Random gen = new Random();
		ConsoleKeyInfo key;
		// По циклу до нажатия ESC
		do
		{
			Console.WriteLine();
			Console.WriteLine("There are {0} animals in the menagerie", mg.Animals.Count);
			Console.WriteLine();
			key = Console.ReadKey(true);
			// Вызываем метод случайного размножения
			Animal someAnimal = mg.RandomBreed();
			// Пытаемся получить детёныша от размножающегося животного
			Animal cub = someAnimal.GetCub();
			// Если детёныш есть
			if (cub != null)
			{
				int randomNameIndex = gen.Next(names.Length);
				cub.Name = names[randomNameIndex];
				Console.WriteLine();
				Console.WriteLine("Ta-dam! We have replenishment of the family!");
				Console.WriteLine("It is a {0} {1}", cub.Specie, cub.Name);
				mg.AddNewAnimal(cub);
			}
		}
		while (key.Key != ConsoleKey.Escape);
	}
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Проблема</h2>
				<p>
					У нас есть класс Улитки и есть класс Черепахи. А черепахи едят улиток. Это значит, что улитка
					также должна быть Feed. Но она не может одновременно наследоваться и от класса Animal и от
					класса Feed.
				</p>
				<p>
					И здесь на помощь приходят Интерфейсы.
				</p>
			</section>
			<section>
				<h2>Полиморфизм интерфейсов</h2>
				<p>
					Также, как и с базовыми классами, объекты, реализующие какой-либо интерфейс, могут быть
					представлены в виде объекта типа этого интерфейса. Такой тип полиморфизма
					называется <span class="purple">Полиморфизм интерфейсов</span>.
				</p>
			</section>
			<section>
				<section>
					<h2>Пример</h2>
					<pre>
						<code class="cs">
// Интерфейс "Лающее"
interface IBarkable
{
	// Метод Лаять
	void Bark(int power);
	// Метод Скулить
	void Whine();
}

// Класс Собаки, реализующего интерфейс "Лающее"
class Dog : IBarkable
{
	public string Name { get; set; }
	public string Breed { get; set; }
	public int Age { get; set; }
	public string Owner { get; set; }

	public virtual void Walk()
	{
		Console.WriteLine("The {0} walks!", Name);
		Random randGen = new Random();
		int rndNumber = randGen.Next(4);
		if (rndNumber == 3)
		{
			this.Pee();
		}
	}

	private int Pee()
	{
		Console.WriteLine("The {0} has urinated..", Name);
		Random randGen = new Random();
		int strenth = randGen.Next(1, 11);
		return strenth;
	}

	public override string ToString()
	{
		return $"Dog named {Name}, with owner {Owner}, {Breed}, {Age} years";
	}

	// Реализация метода Лаять
	public void Bark(int power)
	{
		switch (power)
		{
			case 0:
				Whine();
				break;
			case 1:
				Console.WriteLine(" - Woof...");
				break;
			case 2:
				Console.WriteLine(" - Woof!");
				break;
			case 3:
				Console.WriteLine(" - Woof! Woof! Woof!");
				break;
			case 4:
				Console.WriteLine(" - WOOOOF!!! WOOOFFFF!!!");
				break;
			default:
				Console.WriteLine(" - Quack.");
				break;
		}
	}

	// Реализация метода Скулить
	public void Whine()
	{
		Console.WriteLine(" - Whiiee..");
		Console.WriteLine(" - Whie...");
		Console.WriteLine("   .....");
	}
}

// Класс Полицейская Собака - потомок класса Собаки
class PoliceDog : Dog
{
	// ...
}

// Класс Кота
class Cat
{
	private Random generator;

	// Конструктор
	public Cat()
	{
		// Для инициализации генератора случайных чисел
		generator = new Random();
	}

	// Метод Мяукнуть
	protected string Meow()
	{
		string word = " - Meeeooowwww!";
		Console.WriteLine(word);
		return word;
	}
	
	// Метод Убежать от кого-то лающего
	// В качестве параметра - объект интерфейса
	public void RunAwayFrom(IBarkable barkable)
	{
		// Гавкаем и мяукаем друг на друга
		int rnd, iter = 1;
		do
		{
			Meow();
			rnd = generator.Next(2);
			barkable.Bark(iter);
			++iter;
		}
		while (rnd != 0);
		// И убегаем
		Console.WriteLine("The cat ran away and climbed a tree.\n");
	}
}

class Program
{
	static void Main(string[] args)
	{
		// Создаём экземпляр кота
		Cat cat = new Cat();

		// Экземпляр собаки
		Dog dog1 = new Dog();

		// Вызываем метод кота RunAwayFrom, передавая туда объект собаки
		// Потому что собака - лающее 
		cat.RunAwayFrom(dog1);

		// Создаём экземпляр полицейской собаки
		PoliceDog dog2 = new PoliceDog();

		// Вызываем метод, передаём полицейского пса
		// Полицейская собака тоже лающее
		cat.RunAwayFrom(dog2);

		// Создаём экземпляр собаки и присваеваем объекту интерфейса
		IBarkable barkable = new Dog();

		// Тоже подходит
		cat.RunAwayFrom(barkable);
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Дополняем</h3>
					<pre>
						<code class="cs">
class Drunkard : IBarkable
{

	public void Bark(int power)
	{
		switch (power)
		{
			case 0:
				Whine();
				break;
			case 1:
				Console.WriteLine(" - Wof-f-f..");
				break;
			case 2:
				Console.WriteLine(" - Wooof! Hrraaarf!");
				break;
			case 3:
				Console.WriteLine(" - Hurrrrgff!.. Gh-rrr-aaaaah! Wof!");
				break;
			case 4:
				Console.WriteLine(" - WOF! R-R-RAFF! A new ide suda....");
				break;
			default:
				Console.WriteLine(" - ROF! FOPH! WOF! RGRA-A-A-a-a-a.... Arghf-awww-shaaafff!!");
				break;
		}
	}

	public void Whine()
	{
		Console.WriteLine(" - Ukh!");
	}
}

// ...

Drunkard man = new Drunkard();

cat.RunAwayFrom(man);

IBarkable barkable2 = new Drunkard();

cat.RunAwayFrom(barkable2);
// ...
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Явная реализация интерфейсов</h2>
					<p>
						Помимо обычной реализации членов интерфейса существуем механизм 
						<span class="purple">явной реализации</span>.
					</p>
					<blockquote>
						Явно реализованный член интерфейса будет доступен в объекте только тогда,
						когда объект будет представлен в форме этого интерфейса.
					</blockquote>
					<p>
						С помощью этого можно "прятать" методы внутри классов, а также управлять
						поведением членов класса в зависимости от формы их представления.
					</p>
				</section>
				<section>
					<h2>Синтаксис</h2>
					<p>
						Чтобы явно реализовать элемент интерфейса в классе, перед его именем нужно
						через точку обозначить название интерфейса, которому этот элемент принадлежит:
					</p>
					<pre>
						<code class="cs">
// Интерфейс
interface ITestable
{
	// С одним методом
	void Test();
}

// Класс, реализующий его
class TestClass : ITestable
{
	// Обычная реализация
	public void Test()
	{
		Console.WriteLine("Implicit Interface implementation");
	}

	// Явная реализация для ITestable
	public void ITestable.Test()
	{
		Console.WriteLine("Explicit Interface implementation");
	}
}

class Program
{
	static void Main(string[] args)
	{
		TestClass c = new TestClass();
		// Выведет одно
		c.Test();

		ITestable i = c;
		// Выведет другое
		i.Test();
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Прячем методы</h2>
					<p>
						В классе можно описать только явную реализацию метода интерфейса. Тогда такой
						метод не будет виден в этом классе, даже изнутри, пока его не привести к типу интерфейса.
					</p>
					<pre>
						<code class="cs">
interface ITestable
{
	void Test();
}

class TestClass : ITestable
{
	// Только явная реализация для ITestable
	public void ITestable.Test()
	{
		Console.WriteLine("Explicit Interface implementation");
	}

	// Method in wich we call Test method
	public void TestMethodTest()
	{
		Console.WriteLine("Can I access Test method inside a class?");
		Test();		// Right answer - no
	}
}

class Program
{
	static void Main(string[] args)
	{
		TestClass c = new TestClass();

		// Ошибка - нет такого метода
		c.Test();

		// Аналогично
		c.TestMethodTest();

		ITestable i = c;
		// Сработает
		i.Test();

	}
}
						</code>
					</pre>
				</section>
				<section>
					<h2>Совпадение имён</h2>
					<p>
						В случае совпадения названий методов в Интерфейсах/Классе, для каждого можно
						написать свою реализацию:
					</p>
					<pre>
						<code class="cs">
// Базовый класс Спортсмен
class Sportsman
{
	// Метод Run
	public void Run()
	{
		Console.WriteLine("I am a Sportsman");
	}
}

// Интерфейс Бегун
interface IJogger
{
	// Метод Run
	void Run();
}

// Интерфейс Лыжник
interface ISkier
{
	// И здесь метод Run
	void Run();
}

// Производный класс Атлет, реализующий интерфейсы ISkier, IJogger
class Athlete: Sportsman, ISkier, IJogger
{
	// Перекрывающий метод базового класса метод Run
	public new void Run() 
	{
		Console.WriteLine("I am an Athlete");
	}
	
	// Явная реализация Run для интерфейса ISkier
	void ISkier.Run() 
	{
		Console.WriteLine("I am a Skier");
	}
	
	// Явная реализация Run для интерфейса IJogger
	void IJogger.Run() 
	{
		Console.WriteLine("I am a Jogger");
	}
}

class Program
{
	static void Main(string[] args)
	{
		// Создаём атлета
		var sp = new Athlete();
		// Вызываем метод Run из-под атлета
		sp.Run();
		// Вызываем метод Run из-под спортсмена
		(sp as Sportsman).Run();
		// Вызываем метод Run из-под лыжника
		(sp as ISkier).Run();
		// Вызываем метод Run из-под бегуна
		(sp as IJogger).Run();
	}
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Массив в .NET</h3>
					<p>
						Массив в .NET представлен классом Array, и этот класс реализует интерфейс списка IList.
					</p>
					<p>
						Т.е. в нём есть все методы для работы со списком: Add, Remove, Clear, IndexOf, Count 
						(но большинство из них, конечно же, не рабочие). Увидеть и применить их можно только
						представив массив в виде интерфейса IList.
					</p>
					<pre>
						<code class="cs">
int[] mas = new int[10];
IList&lt;int&gt; vs = mas;
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Гибкость</h2>
				<blockquote>
					Интерфейсы дают неимоверную гибкость.
				</blockquote>
				<p>
					Для полиморфизма, как правило, используют именно интерфейсы. Наследование имеет
					значительное ограничение из-за невозможности иметь нескольких родителей, поэтому
					его на практике применяют в основном только для переиспользования кода.
				</p>
			</section>
			<section>
				<h2>Сила полиморфизма интерфейсов</h2>
				<p>
					Полиморфизм интерфейсов даёт нам необычайную возможность строить программу
					на основе интерфейсов без фиксированной реализации.
				</p>
				<p>
					Такая способность открывает возможность легкой поддержки и
					модификации любых частей кода, расширяемость и адаптируемость, простоту тестирования и
					дополнительных интеграций.
				</p>
			</section>
			<section>
				<h2>Мыслить интерфейсами</h2>
				<p>
					Почти во всех случаях грамотная архитектура ООП приложения должна опираться именно
					на Интерфейсы. Любые зависимости следует представлять в виде интерфейсов, всё
					взаимодействие программных компонентов должно вестись через интерфейсы.
				</p>
				<blockquote>
					Для построения правильной архитектуры ПО нужно мыслить интерфейсами, а не классами.
				</blockquote>
				<a href="https://habr.com/post/30444/">Интерфейсы - для людей, классы - для животных</a>
			</section>
			<section>
				<h2>Животные с интерфейсами</h2>
				<pre>
					<code class="cs">
// Вместо базового класса Пища - интерфейс Съестное
interface IEatable
{
	string Composition { get; set; }
	int KKal { get; set; }
}

// Трава реализует интерфейс съестное
class Grass : IEatable
{
	public string Freshness { get; set; }
	public string Dryness { get; set; }
	public string Composition { get; set; }
	public int KKal { get; set; }

	public override string ToString()
	{
		return "Grass";
	}
}

// Орех реализует интерфейс съестное
class Nut : IEatable
{
	public string Composition { get; set; }
	public int KKal { get; set; }
	public int Strength { get; set; }

	public override string ToString()
	{
		return "Nut";
	}
}

// Листья реализуют интерфейс съестное
class Leaves : IEatable
{
	public int Number { get; set; }
	public string Composition { get; set; }
	public int KKal { get; set; }

	public override string ToString()
	{
		return "Leaves";
	}
}

// Теперь у нас есть интерфейс, описывающий как быть животным
interface IAnimal
{
	string Specie { get; set; }
	string Name { get; set; }
	int Age { get; set; }
	Random Gen { get; }

	bool Breeding();
	IAnimal GetCub();
	bool Eat(IEatable feed);
	string MadeSound();
	string Print();
}

// Черепаха вместо наследования класса реализует интерфейс
class Turtle : IAnimal
{
	// Закрытое поле - булевый флаг, используется в методах для контроля соответствия размножения-детёнышей
	private bool canGetChild;

	private string specie;
	public string Specie
	{
		get
		{
			return specie;
		}
		set
		{
			if (string.Compare(value, "Green Turtle", true) == 0 ||
				string.Compare(value, "Flatback", true) == 0 ||
				string.Compare(value, "Loggerhead", true) == 0)
			{
				specie = value;
			}
		}
	}

	public string Name { get; set; }
	public int Age { get; set; }

	// Интересный способ инициализации
	private Random gen;
	public Random Gen
	{
		get
		{
			if (gen == null)
			{
				gen = new Random();
			}
			return gen;
		}
	}
	
	public Turtle()
	{
		canGetChild = false;
		Specie = "Green Turtle";
	}
	
	// Реализация метода Breeding из интерфейса IAnimal
	public bool Breeding()
	{
		int randInt = Gen.Next(3);
		if (randInt == 0)
		{
			// С шансом 1:3 черепаха откладывает яйцо
			Console.WriteLine("Turtle {0} laid egg on the beach!", Name);
			System.Threading.Thread.Sleep(500);
			Console.WriteLine("...................");
			System.Threading.Thread.Sleep(2000);
			// И переключаем флаг на true
			canGetChild = true;
			Console.WriteLine("Now you can get turtles child!");
			return true;
		}
		else
		{
			// 2:3 что яйца отложить не выйдет
			Console.WriteLine("Turtle {0} failed to lay eggs...", Name);
			return true;
		}
	}

	// Реализация метода GetCub из интерфейса IAnimal
	public IAnimal GetCub()
	{
		// Если было отложено яйцо
		if (canGetChild)
		{
			canGetChild = false;
			int rnd = Gen.Next(2);
			if (rnd != 0)
			{
				// Выдаём черепашку с шансом 1:2
				Console.WriteLine("New turtle hatches from egg!");
				return new Turtle();
			}
			else
			{
				// 1:2 что черепашки не будет
				Console.WriteLine("Oh no! Sand snake catch and kill little turtle!");
				return null;
			}
		}
		else
		{
			// Иначе выдаём пустую ссылку null
			Console.WriteLine("To have a cub, turtle must first breed!");
			return null;
		}
	}

	// Реализация метода Eat из интерфейса IAnimal
	// Принимает корм в виде интерфейса IEatable
	public bool Eat(IEatable feed)
	{
		// Проверям, что тип пищи - трава
		if (feed is Grass || feed is Snail)
		{
			Console.WriteLine("{0} {1} eats {2}", Specie, Name, feed);
			return true;
		}
		else
		{
			// Если не трава, то черепаха не может съесть это
			Console.WriteLine("Turtle can't eat {0}!", feed);
			return false;
		}
	}

	// Реализация метода MadeSound из интерфейса IAnimal
	public string MadeSound()
	{
		var turtleVoice = ".......";
		Console.WriteLine(turtleVoice);
		return turtleVoice;
	}

	// Реализация метода Pring из интерфейса IAnimal
	public string Print()
	{
		string ret = Specie + " " + Name;
		// Будет выводить информацию зелёненьким
		Console.ForegroundColor = ConsoleColor.Green;
		Console.WriteLine(ret);
		Console.ResetColor();
		return ret;
	}
}

// Класс улитки реализует интерфейса IAnimal - значит она животное
// Также улитка может быть съеденой - она реализует интерфейс IEatable
class Snail : IAnimal, IEatable
{
	// Булевый флаг для индикации, отложила ли улитка яйца
	private int breedAttemptLeft;
	// Количество отложенных яиц
	private int eggsCount;

	public string Specie { get; set; }
	public string Name { get; set; }
	public int Age { get; set; }

	private Random gen;
	public Random Gen
	{
		get
		{
			if (gen == null)
			{
				gen = new Random();
			}
			return gen;
		}
	}
	// Конструктор по умолчанию
	public Snail()
	{
		// У улитки есть 5 попытко отложить яйца
		breedAttemptLeft = 5;
		// Изначально у неё нет яиц
		eggsCount = 0;
		Specie = "Snail";
	}

	// Реализация метода Breeding из интерфейса IAnimal
	public bool Breeding()
	{
		if (breedAttemptLeft != 0)
		{
			// Отнимаем попытку
			breedAttemptLeft--;
			int randInt = Gen.Next(5);
			if (randInt == 0 || randInt == 1)
			{
				// С вероятностью 2:5 она откладывает 0-50 яиц
				int eggs = Gen.Next(50);
				Console.WriteLine("Snail {0} buried {1} eggs in the ground!", Name, eggs);
				eggsCount += eggs;
				System.Threading.Thread.Sleep(500);
				Console.WriteLine("...................");
				System.Threading.Thread.Sleep(2000);
				Console.WriteLine("Now eggs can hatch!");
				return true;
			}
			else
			{
				Console.WriteLine("Snail {0} failed to lay eggs...", Name);
				return false;
			}
		}
		else
		{
			if (eggsCount == 0)
			{
				Console.WriteLine("Snail {0} can no longer breed!", Name);
			}
			return false;
		}
	}

	// Реализация метода GetCub из интерфейса IAnimal
	public IAnimal GetCub()
	{
		// Если есть яйца
		if (eggsCount != 0)
		{
			// Можно получать маленьких улиточек
			eggsCount--;
			Console.WriteLine("{0} eggs left...", eggsCount);
			int randInt = Gen.Next(5);
			// Если повезёт, т.к. не из каждого яйца они вылупляются
			if (randInt == 0)
			{
				Console.WriteLine("Ctchhh! There is new Snail!");
				return new Snail();
			}
			else
			{
				Console.WriteLine("Ctchhh! But.. Egg is empty...");
				return null;
			}
		}
		else
		{
			Console.WriteLine("No eggs - no cubs. Sorry.");
			return null;
		}
	}

	// Реализация метода Eat из интерфейса IAnimal
	public bool Eat(IEatable feed)
	{
		// Если пища это Листья
		if (feed is Leaves)
		{
			// То можно есть
			Console.WriteLine("{0} {1} eats {2}", Specie, Name, feed);
			return true;
		}
		else
		{
			// Иначе не стоит
			Console.WriteLine("You're kidding! Snail can't eat {0}!", feed);
			return false;
		}
	}

	// Реализация метода MadeSound из интерфейса IAnimal
	public string MadeSound()
	{
		var snailSong = "Two little eyes, one and two.\n" +
						"One pretty shell." +
						"Nice to meet you." +
						"He has no legs, just a tail." +
						"It's a snail, it's a snail, it's a snail.";
		Console.WriteLine(snailSong);
		return snailSong;
	}

	// Реализация метода Pring из интерфейса IAnimal
	public string Print()
	{
		string ret = Specie + " " + Name;
		// Будет выводить информацию красненьким
		Console.ForegroundColor = ConsoleColor.Red;
		Console.WriteLine(ret);
		Console.ResetColor();
		return ret;
	}

	// Реализация интерфейса IEatable в классе Улитки
	public string Composition { get; set; }
	public int KKal { get; set; }
	
	public override string ToString()
	{
		return Specie;
	}
}

// Класс Зверинца
class Menagerie
{
	// Список животных, теперь через интерфейс
	public List&lt;IAnimal&gt; Animals { get; set; }

	// Индексатор
	public IAnimal this[int index]
	{
		get { return Animals[index]; }
		set { Animals[index] = value; }
	}

	// Конструктор для инициализации списка
	public Menagerie()
	{
		Animals = new List&lt;IAnimal&gt;();
	}

	// Метод для добавления нового животного в зверинец
	public void AddNewAnimal(IAnimal a)
	{
		Animals.Add(a);
	}

	// Метод для кормления кого-то, кто реализует интерфейс IAnimal,
	// чем-то, что реализует интерфейс IEatable
	public void FeedAnimal(IAnimal a, IEatable f, int quantity = 1)
	{
		// Ищем это животное в нашем зверинце
		int index = Animals.IndexOf(a);
		// Если оно присутствует
		if (index != -1)
		{
			// Если корм - это другое животное
			if (f is IAnimal liveFeed)
			{
				// Пытаемся скормить
				bool itIsEated = Animals[index].Eat(f);
				// Если животное успешно съели, и оно было в нашем зверинце (было, потому что здесь же оно и удаляется)
				if (itIsEated && Animals.Remove(liveFeed))
				{
					// Ругаем проектировщиков такой системы
					Console.WriteLine("\nWhat are you do! It was " + liveFeed.Name + "!!\n");
				}

			}
			// Иначе можно не волноваться
			else
			{
				// Кормим quantity раз
				for (int i = 0; i < quantity; ++i)
				{
					Animals[index].Eat(f);
				}
			}
		}
	}

	// Метод для размножения случайного животного в зверинце
	public IAnimal RandomBreed()
	{
		Random random = new Random();
		int i = random.Next(Animals.Count);
		// Выбираем случайное животное
		IAnimal animal = Animals[i];
		// Вызываем метод размножения
		animal.Breeding();
		// Возвращаем животное, которое размножалось
		return animal;
	}

	// Метод для вывода на консоль пронумерованного списка животных в зверинце
	public void ShowAnimals()
	{
		Console.WriteLine();
		for (int i = 1; i < Animals.Count + 1; ++i)
		{
			Console.Write(" {0,2}. ", i);
			// С применением метода IAnimal.Print
			Animals[i - 1].Print();
		}
		Console.WriteLine();
	}
}

class Program
{
	static void Main(string[] args)
	{
		// Черепаха Боб
		Turtle t = new Turtle();
		t.Name = "Bob";

		// Улитка Мэгги
		Snail s = new Snail();
		s.Name = "Maggy";

		// Улитка Маркус
		Snail ss = new Snail();
		ss.Name = "Markus";

		// Создаём зверинец
		Menagerie mg = new Menagerie();
		// Забрасываем в него нашу живность
		mg.AddNewAnimal(t);
		mg.AddNewAnimal(s);
		mg.AddNewAnimal(ss);

		// Создаём листья
		Leaves leaves = new Leaves();
		// Кормим Маркуса 5 листьями
		mg.FeedAnimal(ss, leaves, 5);
		// Кормим боба листиком
		mg.FeedAnimal(t, leaves);

		// Пытаемся скормить Маркуса Мэгги
		mg.FeedAnimal(s, ss);

		// Отправляем Маркуса на закуску Бобу
		mg.FeedAnimal(t, ss);


		string[] names = { "Austin", "Brock", "Caleb", "Dominic", "Emmett", "Finn", "Guy", "Hogan", "Irving",
							"Jace", "Kingston", "Lambert", "Mickey", "Nolan", "Oliver", "Parker", "Quinn",
							"Ramsey", "Samson", "Thomas", "Upton", "Vinny", "Wade", "Xander", "York", "Zane" };

		Random gen = new Random();
		ConsoleKeyInfo key;
		Console.WriteLine("Press ESC to Exit, SPACE to Show animals in the menagerie, ANY KEY to breeding attempt:");
		// По циклу до нажатия ESC
		do
		{
			Console.WriteLine();
			Console.WriteLine("There are {0} animals in the menagerie", mg.Animals.Count);
			Console.WriteLine();
			key = Console.ReadKey(true);
			// На пробел
			switch (key.Key)
			{
				case ConsoleKey.Spacebar:
					// Вызываем метод зверинца ShowAnimals
					mg.ShowAnimals();
					break;
				case ConsoleKey.Escape:
					break;
				default:
					// Вызываем метод случайного размножения
					IAnimal someAnimal = mg.RandomBreed();
					// Пытаемся получить детёныша от размножающегося животного
					IAnimal cub = someAnimal.GetCub();
					// Если детёныш есть
					if (cub != null)
					{
						// Выбираем ему случайное имя из массива имён names
						int randomNameIndex = gen.Next(names.Length);
						cub.Name = names[randomNameIndex];
						Console.WriteLine();
						Console.WriteLine("Ta-dah! We have replenishment of the family!");
						// Добавляем его в зверинец
						mg.AddNewAnimal(cub);
						Console.Write("It is a ");
						cub.Print();
					}
					break;
			}

		}
		while (key.Key != ConsoleKey.Escape);
	}
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Пример 2</h2>
// Интерфейс Создатель музыки
interface IMusicMaker
{
	string Type { get; set; }
	void Play();
}

// Класс Гитара, реализует интерфейса Создатель музыки
class Guitar : IMusicMaker
{
	// Свойство Количество струн
	public int StringCount { get; set; }

	// Свойство тип - из интерфейса IMusicMaker
	public string Type { get; set; }

	// Конструктор по умолчанию
	public Guitar()
	{
		Type = "Spanish guitar";
		StringCount = 6;
	}

	// Конструктор с параметрами
	public Guitar(string type, int strings)
	{
		Type = type;
		StringCount = strings;
	}

	// Реализация метода Play из интерфейса
	// Играет музыку гитары
	public void Play()
	{
		Console.WriteLine("Jug-jug-strum-neowwwwwhh");
		Console.WriteLine("Wwwaahhhhhwahwahwahwahhhh");
		Console.WriteLine("Neowwwwwwh... strum");
		Console.WriteLine("Neowh-newh-newh-newh-newh-newwwwhh..");
	}

}

// Класс Трубы, реализует интерфейс Создателя музыки
class Trumpet : IMusicMaker
{
	// Свойство Тип из интерфейса IMusicMaker
	public string Type { get; set; }

	// Конструктор по умолчанию
	public Trumpet()
	{
		Type = "Piccolo trumpet";
	}

	// Конструктор с параметром
	public Trumpet(string type)
	{
		Type = type;
	}

	// Реализация метода Play из интерфейса
	// Играет звуки трубы
	public void Play()
	{
		Console.WriteLine("Thuuuuuu! Thu! Thu!");
		Console.WriteLine("Pah-pa-pah!");
		Console.WriteLine("Thuuuuuu-rhu! Thu! Thu! Rhuuh!");
	}

}

// Класс Барабанов, реализует интерфейс Создателя музыки
class DrumKit : IMusicMaker
{
	// Свойство Количество барабанов
	public int Drums { get; set; }
	// Свойство Тип из интерфейса IMusicMaker
	public string Type { get; set; }

	// Конструктор по умолчанию
	public DrumKit()
	{
		Type = "Four-piece kit";
		Drums = 4;
	}

	// Конструктор с параметрами
	public DrumKit(string type, int drums)
	{
		Type = type;
		Drums = drums;
	}

	// Реализация метода Play из интерфейса
	// Издаёт звуки барабанов
	public void Play()
	{
		Console.WriteLine("Rub-a-dub dabum tish!");
		Console.WriteLine("Bum! Brrum! Brrrumble!!!!");
		Console.WriteLine("Pump-a-rum-parum Pump-a-rum! Tish! ");
	}
}

// Интерфейс Музыканта
interface IMusicPlayer
{
	IMusicMaker Instrument { get; set; }
	void PerformMusic();
}
// Класс Музыкант
class Musician : IMusicPlayer
{
	// Свойства Имя, Опыт
	public string Name { get; private set; }
	public int Experience { get; set; }

	// Свойство Инструмент теперь от интерфейса IMusicPlayer
	public IMusicMaker Instrument { get; set; }

	// Конструктор с параметрами
	public Musician(string name, int exp, IMusicMaker instrum)
	{
		this.Name = name;
		this.Experience = exp;
		this.Instrument = instrum;
	}

	// Метод "Исполнять музыку" от интерфейса IMusicPlayer
	public void PerformMusic()
	{
		// Вызывает метод Play для его текущего инструмента
		this.Instrument.Play();
	}

}

// Класс Воробей, который реализует интерфейс Исполнителя музыки
class Sparrow : IMusicPlayer
{
	// Свойство Гнездо
	public string Nest { get; set; }
	// Свойство Вид
	public string Kind { get; set; }

	// Реализация интерфейса Исполнителя музыки
	public IMusicMaker Instrument { get; set; }

	public void PerformMusic()
	{
		if (Instrument is Voice voice)
		{
			for (int i = 0; i < 3; ++i)
			{
				voice.SetVoice();
				voice.Play();
			}
		}
	}
}

// Класс Voice, реализующий интерфейс IMusicMaker
class Voice : IMusicMaker
{
	// Свойство Type из интерфейса IMusicMaker
	public string Type { get; set; }

	// Свойство - список издаваемых звуков
	private List&lt;string&gt; voices;

	// Конструктор
	public Voice()
	{
		voices = new List&lt;string&gt;();
	}

	// Метод для задания звуков
	public void SetVoice(params string[] voices)
	{
		this.voices = new List&lt;string&gt;(voices);
	}

	// Метод Play из интерфейса IMusicMaker
	public void Play()
	{
		Random randGen = new Random();
		// Выбираем случайным образом количество повторений
		int voiceIndex, num = randGen.Next(1, voices.Count + 1);
		for (int i = 0; i < num; ++i)
		{
			// Выбираем случайный звук из списка
			voiceIndex = randGen.Next(voices.Count);
			Console.WriteLine(voices[voiceIndex]);
		}
		Console.WriteLine();
	}
}

class Program
{
	static void Main(string[] args)
	{
		// Создаём инструменты
		Guitar guitar = new Guitar();
		Trumpet trumpet = new Trumpet("Baroque trumpet");
		DrumKit drumKit = new DrumKit("Electronic drums", 8);

		// Создаём музыканта
		Musician musician = new Musician("Robert", 12, guitar);
		ConsoleKeyInfo key;
		do
		{
			Console.WriteLine("Choose an instrument or start playing music!");
			Console.WriteLine("  1 - Select Guitar");
			Console.WriteLine("  2 - Select Trumpet");
			Console.WriteLine("  3 - Select DrumKit");
			Console.WriteLine("  Other - Start Playing");
			Console.WriteLine("  ESC - Exit");
			key = Console.ReadKey(true);
			// Выбор инструмента
			switch (key.Key)
			{
				// В зависимости от кейса даём музыканту разные инструменты
				case ConsoleKey.D1:
					musician.Instrument = guitar;
					break;
				case ConsoleKey.D2:
					musician.Instrument = trumpet;
					break;
				case ConsoleKey.D3:
					musician.Instrument = drumKit;
					break;
				case ConsoleKey.Escape:
					break;
				default:
					Console.WriteLine("To stop playing music press any key.");
					do
					{
						// Просто вызываем метод PerformMusic
						musician.PerformMusic();
						System.Threading.Thread.Sleep(1000);
					}
					while (!Console.KeyAvailable);
					// Пока не будет нажата любая клавиша
					Console.ReadKey(true);
					break;
			}
			Console.Clear();
		}
		while (key.Key != ConsoleKey.Escape);
		// Заканчиваем программу по нажатию ESC
	}
}
			</section>
			<section>
				<h2>Пример 3</h2>
				<pre>
					<code class="cs">
// Интерфейс Логгера
interface ILogger
{
	// С одним методом - для записи строки
	void Log(string text);
}

// Перечисление видов логгеров
enum LoggerType { Console, File }

// Статический класс для создания логгера
static class LoggerFabric
{
	// Вложенные типы: классы, видимые только внутри класса:

	// Приватный класс Консольного логгера, реализует интерфейс ILogger
	private class ConsoleLogger : ILogger
	{
		// Реализация метода Log из интерфейса ILogger
		public void Log(string text)
		{
			// Выводим строку на консоль
			Console.WriteLine(text);
		}
	}

	// Приватный класс Файлового логгера, тоже реализует интерфейс логгера
	private class FileLogger : ILogger
	{
		// Приватное поле только для чтения для имени файла
		private readonly string filename;

		// Конструктор по умолчанию
		public FileLogger()
		{
			// Задаём имя файла
			filename = "log.log";
		}

		// Реализация метода Log из интерфейса ILogger
		public void Log(string text)
		{
			// Записываем строку в файл
			File.AppendAllText(filename, text + "\n");
		}
	}

	// Обычные члены класса LoggerFabric:

	// Приватный статический словарь
	// Ключом выступаем элемент перечисления LoggerType
	// Значением - объект, реализующий интерфейс логгера
	private static Dictionary&lt;LoggerType, ILogger&gt; loggers;

	// Статический конструктор
	static LoggerFabric()
	{
		// Создание списка
		loggers = new Dictionary&lt;LoggerType, ILogger&gt;();
	}

	// Публичный статический метод Получения логгера
	// Выдаёт запрашиваемый логгер, по типу логгера
	public static ILogger GetLogger(LoggerType type)
	{
		ILogger logger;
		// Пытаемся получить логгер из словаря по переданному типу логгера в качестве ключа
		if (loggers.TryGetValue(type, out logger))
		{
			// Если он есть, возвращаем его
			return logger;
		}
		else
		{
			// Если элемента с таким ключом в словаре нет
			// То, в зависимости от переданного типа логгера
			switch (type)
			{
				case LoggerType.Console:
					// Если это Console - создаём объект класса консольного логгера
					logger = new ConsoleLogger();
					break;
				case LoggerType.File:
					// Если File - создаём объект класса файлового логгера
					logger = new FileLogger();
					break;
			}
			// Добавляем созданный объект логгера в словарь по ключу его типа
			loggers.Add(type, logger);
			// И возвращаем его
			return logger;
		}
	}
}

class Program
{
	static void Main(string[] args)
	{
		ILogger console = LoggerFabric.GetLogger(LoggerType.Console);
		console.Log("First String to Console Logger");
		console.Log("Second string to Console Logger");
		console.Log("Third string to Console Logger");

		ILogger file = LoggerFabric.GetLogger(LoggerType.File);
		file.Log("First String to File Logger");
		file.Log("Second string to File Logger");
		file.Log("Third string to File Logger");

		ILogger file2 = LoggerFabric.GetLogger(LoggerType.File);
		console.Log((file == file2).ToString());
	}
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Стандартные интерфейсы .NET</h2>
				<p>
					В .NET есть много готовых интерфейсов, которые можно использовать на своих классах,
					чтобы назначить им какую-либо функциональность.
				</p>
				<ul>
					<li>IClonable</li>
					<li>IComparable</li>
					<li>IEnumerable, IEnumerator</li>
					<li>IList</li>
					<li>IConvertible</li>
					<li>IFormattable</li>
				</ul>
			</section>
			<section>
				<h2>Пример с IFormattable</h2>
				<pre>
					<code class="cs">
// Класс Температуры, реализующий стандартный интерфейс IFormattable
public class Temperature : IFormattable
{
	// Закрытое поле для хранения температуры (в Цельсиях)
	private decimal temp;

	// Конструктор
	public Temperature(decimal temperature)
	{
		// Проверяем адекватность значения
		if (temperature < -273.15m)
			throw new ArgumentOutOfRangeException(string.Format("{0} is less than absolute zero.",
													temperature));
		this.temp = temperature;
	}

	// Свойство для получения температуры в Цельсиях
	public decimal Celsius
	{
		get { return temp; }
	}

	// Свойство для получения температуры в Фаренгейтах
	public decimal Fahrenheit
	{
		get { return temp * 9 / 5 + 32; }
	}

	// Свойство для получения температуры в Кельвинах
	public decimal Kelvin
	{
		get { return temp + 273.15m; }
	}

	// Переопределение метода ToString от Object-а
	public override string ToString()
	{
		// Вызываем ToString с форматированием по культуре
		return this.ToString("G", CultureInfo.CurrentCulture);
	}

	// Перегрузка метода ToString с одним параметром - форматом
	public string ToString(string format)
	{
		// Вызываем ToString с форматированием по культуре
		return this.ToString(format, CultureInfo.CurrentCulture);
	}

	// Перегрузка ToString с параметрами формата и культуры, в соответствии с которой нужно провести форматирование
	public string ToString(string format, IFormatProvider provider)
	{
		// Если формат не задан
		if (string.IsNullOrEmpty(format))
		{
			// Задаём как глобальный
			format = "G";
		}
		// Если культура не задана
		if (provider == null)
		{
			// Задаём как текущую культуру в системе
			provider = CultureInfo.CurrentCulture;
		}
		// В зависимости от переданного формата
		switch (format.ToUpperInvariant())
		{
			case "G":
			case "C":
				// Если G или C возвращаем в градусах Цельсия
				return temp.ToString("F2", provider) + " °C";
			case "F":
				// Если F - в градусах Фаренгейта
				return Fahrenheit.ToString("F2", provider) + " °F";
			case "K":
				// Если K - в Кельвинах
				return Kelvin.ToString("F2", provider) + " K";
			default:
				// Если какой-то другой формат - исключение
				throw new FormatException(string.Format("The {0} format string is not supported.", format));
		}
	}
}

class Program
{
	public static void Main()
	{
		// Создаём объект температуры 
		Temperature temp1 = new Temperature(0);
		// Используем наше форматирование во WriteLine
		Console.WriteLine("{0:C} (Celsius) = {0:K} (Kelvin) = {0:F} (Fahrenheit)\n", temp1);

		// Создаём новый объект температуры
		temp1 = new Temperature(-40);
		// Используем метод форматирования с разными вариантами CultureInfo
		// Для текущей культуры установленной в системе
		Console.WriteLine(string.Format(CultureInfo.CurrentCulture, "{0:C} (Celsius) = {0:K} (Kelvin) = {0:F} (Fahrenheit)", temp1));
		// Для французской культуры
		Console.WriteLine(string.Format(new CultureInfo("fr-FR"), "{0:C} (Celsius) = {0:K} (Kelvin) = {0:F} (Fahrenheit)\n", temp1));

		// Опять создаём новый объект температуры
		temp1 = new Temperature(32);
		// Выводим консоль с использованием версии ToString с форматом
		Console.WriteLine("{0} (Celsius) = {1} (Kelvin) = {2} (Fahrenheit)\n",
							temp1.ToString("C"), temp1.ToString("K"), temp1.ToString("F"));
	}
}
					</code>
				</pre>
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
    <aside id="presentable-icon-close">
        <a title="К списку материалов" href="../../index.html#/1">
            <i class="fa fa-times fa-2x"></i>
        </a>
    </aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>